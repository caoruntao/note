Enviroment profile
Properties yaml
ApplicationContext启动时添加Propert



Import
ImportSelector
ImportBeanDifinitionRegistrar
处理:
ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry:
	#processConfigBeanDefinitions:
		ConfigurationClassParser#parse:
			#processConfigurationClass:
				#doProcessConfigurationClass:
					#processImports:ImportSelector/ImportBeanDefinitionRegistrar/普通Configuration类
		#loadBeanDefinitions:


#populateBean:
	#applyPropertyValues:
		BeanDefinitionValueResolver#resolveValueIfNecessary:
		#convertForProperty:
		PropertyValue#setConvertedValue:
		PropertyAccessor#setPropertyValues:
			AbstractNestablePropertyAccessor#setPropertyValue:
				#processLocalProperty:
					PropertyHandler#setValue:
						Method#invoke:


@Configuration处理过程: Springboot2.7
	SpringApplication#run:  Spring Boot启动类
		SpringApplication#createApplicationContext: 创建Spring上下文(有些Spring上下文还会创建BeanFactory)
			AnnotationConfigServletWebServerApplicationContext.Factory#create:
				AnnotatedBeanDefinitionReader: 注册指定的class
					AnnotationConfigUtils#registerAnnotationConfigProcessors: 注册AnnotationConfigProcessors
				ClassPathBeanDefinitionScanner: 扫描置顶路径，并将扫描到的BeanDefinition注册
					设置Environment和ResourceLoader
		SpringApplication#prepareContext
			SpringApplication#load: 将Springboot入口类作为配置类(@Configuration标注)注册到BeanFactory
		SpringApplication#refreshContext: 启动Spring上下文
			AbstractApplicationContext#refresh:
				AbstractApplicationContext#invokeBeanFactoryPostProcessors:
					PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors:
						ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry:
							ConfigurationClassPostProcessor#processConfigBeanDefinitions:
								ConfigurationClassUtils#checkConfigurationClassCandidate: 筛选ConfigurationClass候选者
									ConfigurationClassUtils#isConfigurationCandidate: 有@Bean注释的方法也被视为ConfigurationClass
							ConfigurationClassParser#parse
								ConfigurationClassParser#processConfigurationClass
									ConfigurationClassParser#doProcessConfigurationClass:
										ConfigurationClassParser#processMemberClasses: 处理嵌套的ConfigurationClass
										ConfigurationClassParser#processPropertySource: 处理@PropertySource注解
										ComponentScanAnnotationParser#parse: 处理@ComponentScan注解
										ConfigurationClassParser#processImports: 处理@Import注解
										ConfigurationClass#addImportedResource: 处理@ImportResource 注解
										ConfigurationClass#addBeanMethod: 识别@Bean标注的的方法
										处理父类，如果父类也有相关方法
							ConfigurationClassBeanDefinitionReader#loadBeanDefinitions
								ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForConfigurationClass
									ConfigurationClassBeanDefinitionReader#registerBeanDefinitionForImportedConfigurationClass: 将@Import导入的类注册
									ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForBeanMethod: 
										将@Bean注释的方法注册为ConfigurationClassBeanDefinitionReader.ConfigurationClassBeanDefinition，且将@Bean注释的方法注册为FactoryMethod，这样创建时还会被Spring处理，但是创建实例时会使用该方法创建而不是使用反射创建。
									ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsFromImportedResources: 将@ImportResource导入的类注册
									ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsFromRegistrars: 将@ImportBeanDefinitionRegistrar导入的类注册



一、网络原理
OSI 与 TCP/IP 各层的结构与功能，都有哪些协议
应用层：为应用程序提供服务。HTTP、HTTPS、FTP、SMTP、POP3.
表示层：数据格式转换，数据加密解密
会话层：建立、维持和管理会话
传输层：建立、维持和管理端到端的连接。TCP、UDP。
网络层：IP寻址及路由。IP协议
数据链路层：介质访问和链路管理。
物理层：物理层

应用层
传输层
网络层
物理链路层

TCP 建立连接的过程，为什么要三次握手？
	确保双方已经建立稳定的链接。在不可靠的信道进行可靠的数据传输。
	防止已失效的连接请求报文传到服务端
	防止Client发送连接请求，延迟到达Server，这样Client会认为是无效的，Server会认为是一个新的链接，并发送确认数据。如果不采用三次握手，这样Server会保持着连接，浪费资源

TCP、UDP 协议的区别，各自的应用场景
	面向连接。TCP是可靠的协议，会保证数据都会收到，适合数据比较重要的小数据传输。只支持点对点的数据传输。字节流。
	无连接。UDP是不可靠的协议，只会尽量保持送达，适合数据不太重要的大数据传输。支持多播，广播。报文。
打开浏览器，输入 URL 地址，访问主页的过程
	访问DNS服务器，根据域名获取服务器IP，然后根据获取的IP去访问服务器

HTTP 有哪些方法？
	GET POST PUT DELETE

HTTP 和 HTTPS 有什么区别？
	HTTP的数据是明文传输的，是不安全的。80端口。
	HTTPS的数据是由证书里公钥加密后进行传输的，是安全的。443端口。

二、Java 核心技术
HashMap 底层数据结构是什么，时间复杂度多少？
	数组+链表。桶O(1)，链表O(n)
	数据覆盖
	死循环(尾插法)

JDK 8 中对 HashMap 做了怎样的优化？
	红黑树(链表查询变快)，桶长度大于64，并且链表长度大于8则变为红黑树。如果链表长度小于6则退化为链表。
	修改尾插法为头插法(解决死循环)
	1.8 put：
		如果当前桶为空，则需要初始化
		根据hash查找具体的桶，如果为空，则直接新建
			不为空，则遍历，存在相同的key则覆盖
				不存在，则插入(如果是红黑树，则插入红黑树结点。如果是链表，则插入在尾部插入链表结点)
		判断是否需要转化为红黑树
		判断是否需要扩容
	get：
		根据hash定位桶，然后进行遍历
	

HashMap 和 TreeMap 什么区别？
	HashMap是数组+链表+红黑树，TreeMap是红黑树
	HashMap是根据hashcode进行比较的，TreeMap是根据compare接口进行比较的。

ConcurrentHashMap 的实现原理
	以前是分段锁，现在是CAS+synchronized。以前链表，现在红黑树。

包装类的缓存机制如何应用
	Integer的缓存范围为-128,127，在此范围如果不是new Integer的话，那么返回的为同一对象

Error 和 Exception 有什么区别？
	Error是程序不可修复的错误，Exception是程序可以修复的错误

通过一个例子描述下 BIO、NIO、AIO 三者的区别？
	BIO：去包子铺买包子，有三个员工，每个员工只能服务一个顾客，从顾客付钱到给顾客包子，流程不走完，没办法服务下一个顾客。
	NIO：多路复用，还是那个包子铺，一个员工负责收费，其他两个员工负责拿包子，这样子，所有的顾客都可以付钱，付完钱后通知后面的员工拿包子给客户。
	AIO：还是那个包子铺，买包子时直接付款，然后去办其他事情，等包子准备好了，在通知顾客来取。

动态代理实现有几种方式？
	JDK动态代理，只能代理接口，继承Proxy。Proxy.newInstance，需要InvocationHandler。
	CGLIB字节码提升，可以代理类，生成的代理类为目标类的子类。


阐述 JDBC 操作数据库的步骤？
	加载Driver类
	获取Connect连接
	生成执行语句
	执行语句
	获取结果
	关闭连接

Lambda 表达式有哪些应用？
	匿名内部类(单接口)，可以方便的遍历list	

三、Java 并发编程
线程有哪几种状态？
	创建时，准备时，运行时，结束时，阻塞时，等锁
创建线程池需要指定什么参数？
	核心线程数，等待队列，最大线程数，空闲时间，线程工厂，拒绝策略

线程池底层如何实现，工作原理怎样？
	Excutors->ThreadPoolExecutor->AbstractExecutorService->ExecutorService->Executor

	提交一个任务时，
		如果核心线程数没满，则创建核心线程数
			如果已满则添加到等待队列，如果等待队列已满，
				则看最大线程数是否已满，未满则新建线程
					如果最大线程数已满，则根据拒绝策略拒绝任务

	拒绝策略：
		DiscardOldestPolicy:抛弃等待队列中等待时间最长的任务
		RejectHandler:
		AbortPolicy:抛出异常RejectedExecutionException，默认策略
		CallerRunsPolicy:交给当前线程去做
		DiscardPolicy:直接抛弃该任务，不报错
		
并发编程的三大特性：
	原子性
	可见性
	有序性

volatile 的实现原理是什么？
	内存屏障，可以保证可见行和有序性

Synchronized 和 Lock 什么区别？
	Synchronized由系统决定加锁解锁的地方，Lock可以自己决定加锁解锁的地方。

Java 中有哪些锁？有什么区别？
	公平锁和非公平锁，乐观锁和悲观锁，共享锁和独占锁，自旋锁，
	锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁

Synchronized 锁升级的原理是什么？
	https://www.cnblogs.com/paddix/p/5405678.html

使用 ThreadLocal 有哪些注意事项？
	用完要及时清除

CAS 如何实现的？
	compare and swap：乐观锁，根据期望值是否相同来判断是否操作

Thread 类的 sleep() 方法和对象的 wait() 方法都可以让线程暂停执行，它们有什么区别？
	sleep会自动苏醒，不会释放占用的锁，wait需要notify或者notifyAll唤醒，会释放占用的锁

守护线程是什么？
	依赖于普通线程，当普通线程全部退出时，守护线程也会退出

说一下 Atomic 的原理？
	乐观锁，设置前会拿以前的值去比较，如果相同则更新

如何用 Java 实现生产者消费者？
	
Java 内存模型是什么？

JMM 在并发中有什么应用？

四、Java 虚拟机
描述一下 JVM 的内存结构？
	堆：存放对象
	栈：存放引用
	元空间：存放类信息

Java 8 的内存分化有哪些改进？
	永久代变成元空间，元空间可以收缩

有哪些对象分配规则？
	Java 对象创建过程

描述 JVM 加载 class 文件的机制？

双亲委派模型是什么？
	先将任务给父类去执行，父类执行不了在由自己执行

字节码是什么？字节码增强有哪些？
JVM 有哪些编译优化？
常见的垃圾回收算法和收集器有哪些？
如何打印虚拟机堆栈信息？
五、Spring 系列
什么是 AOP，AOP 的作用是什么？
	面向切面编程，在不侵入代码的前提下，对代码进行增强，比如记录日志，添加权限验证等功能。

如何理解 Spring 的 IOC 和 DI？

CGLIB 和 JDK 动态代理什么区别？
	CGLIB支持类
	JDK支持接口，继承Proxy

Spring Boot 支持哪些嵌入式容器，如何配置？
六、数据库
MySQL 中 MyISAM 与 InnoDB 引擎的区别
	MyISAM不支持事务
	InnoDB支持事务
MySQL InnoDB 的默认隔离级别是什么？
	可重复读
举一个数据库死锁的例子，MySQL 怎么解决死锁？
	事务A操作表A后要去操作B表，同时事务B操作表B后要去操作A表

MySQL InnoDB 存储的文件结构，为什么使用 B-Tree（B+Tree）？
	二叉树：如果是顺序插入，则会退化为链表
	平衡二叉树：左右深度绝对值不能超过1
	多路平衡二叉树：一个节点存多个数据
	B树：只有叶子节点存数据，其他节点存范围
	B+树：叶子节点相连接，如果是范围查询，只查一次，然后随着叶子查。

索引的类型有哪些？
	Hash：对范围查询无能为力
	Tree

如何创建合理的索引，索引如何优化？
	在使用比较频繁的字段建立索引，在数据离散度比较大的数据上建立索引，如果多个联合查询，可以考虑使用联合索引

索引失效有哪几种情况？
	使用了!= <>操作符
	使用了or来连接条件
	联合索引，不符合最左原则
	使用了函数，或者类型转换，比如字符不加引号，然后函数会转换为字符，在where中进行了计算
	like以%开头
	扫描了NULL
	扫描量比较大，所以进行了全表扫描
	
…
七、分库分表
为什么要分库分表？
	分库：数据库表太多，连接非常大，将表按照业务类型放到不同的数据库中。
	分表：单表数据量太大。

如何解决分库分表主键问题？
	不采用自增长主键，由程序控制主键的生成，比如全局唯一，按顺序生成。

分库分表有哪些中间件，有什么优点和缺点？
	shardingJDBC，优点可以提高数据库的存储量和性能，缺点，因为数据分库，所以有分布式事务问题，数据分表，数据分布在不同表要查询多个表。
…
八、分布式缓存
怎么保证缓存与数据库的双写一致性
	先删除缓存，在更新数据库，更新完数据库在删除缓存。

Redis 新版本支持多线程，性能怎么样？

Redis 有什么数据类型，都在哪些场景下使用？
	String List Hash Set Zset
Redis 的高可用有哪些机制？
	主从，哨兵，集群
Redis 的持久化有哪些方式？
	RDB AOF
Redis 过期策略都有哪些？
	有过期时间的，最接近过期时间的
				最少使用的
				随机删除
	无过期时间的，最少使用的
				随机删除
				不删除
写一下 Java 版本的 LRU 代码？

九、分布式服务框架
Dubbo 的架构和服务调用过程怎样？

注册中心挂了可以继续通信吗？
	程序间可以继续通信，因为有缓存

ZooKeeper 的原理是什么？
	ZAB协议，高一执行，由主节点控制写，多个节点控制读

Dubbo 支持哪些序列化协议？
十、分布式消息队列
消息队列有什么作用？
	削峰，解耦，异步

如何保证消息队列的高可用？
	多节点

如何保证消息不被重复消费？
	幂等性

不同消息队列的选型和对比

十一、分布式系统
CAP 理论是什么？
	C：一致性
	A：可用性
	P：网络分区容错

Base 理论是什么？
	BA：基本可用
	S：软状态
	E：最终一致性

数据一致性有哪几种？
	强一致性
	最终一致性

分布式事务有哪些解决方案？
	二阶段提交
	TCC
	SAGA

如何使用 Redis 实现分布式锁？
	做标识
	失效时间
	谁加锁谁解锁

负载均衡有哪些常见策略？
	随机
	轮训
	权重
	Hash
	最少连接


1-4 5-8 9-12
1.1-4和5-8比
	平，说明问题小球在9-12，不知轻重
		2.从1-4和9-12种各取3个比，如果平，则说明问题小球是剩下那个，对比正常的就知道轻重；如果不平，则知道问题小球的轻重，然后从中选两个对比，平的话，问题小球是另一个，不平的话能根据轻重判断出来
1.1-4和5-8比不平，记录1-4的轻重
	2.轻(1-4轻，或5-8重)：1，5，6，7 和8，3个正常的比，
		如果平，则问题小球在2，3，4并且轻，取出两个对比就知道是那个
		如果轻，则可能是1轻，也可能是8重
		如果重，则可能是5，6，7重，取出两个对比就知道是那个
	  重(1-4重，或5-8轻)：1，5，6，7和8，3个正常的比
	  	如果平，则问题小球在2，3，4并且重，取出两个对比就知道是那个
	  	如果轻，则说明5，6，7轻，取出两个对比就知道结果
	  	如果重，则可能是1重，或者8轻

mysql
	表连接
		内连接
			inner join
		外连接
			left join
			right join
			full join
			先过滤，在连接
				select t1.*, t2.* 
				from (select * from t1 where 条件) 
				right join t2 on 连接条件
		交叉连接
			cross join
	explain/describe/desc
spring boot
 自动装配
 	在META-INF/spring.factories中添加key为EnableAutoConfiguration全限定类名，value为你要加载的类，这样在spring boot自动装配时会将你要加载的类加载
 	spi
 		解偶，面向接口编程，具体实现类在文件中指定，方便替换。在META-INF/services下创建名字为接口全限定名的文件，内容为其要加载的实现类。
 lambda
 	peek:
 		Consumer，无返回值，因此返回的Stream和之前的Stream一样。但是修改Stream中元素对象的属性，对象还是会发生变化的
 	map:
 		Function，有返回值，因此返回的Stream就是你的返回值组成的Stream。同时修改Stream中元素对象的属性，对象也会发生变化的。
 	flatmap:
 		将元素铺平(如Array)。如果你想将一个String，分割为一个个字符，但是你又不想接收一个Array<String>，那么你可以用flatmap，该方法会将Array的各个元素取出铺平。
 		List<String> collect = stringList.stream().flatMap(s -> Arrays.stream(s.split(""))).collect(Collectors.toList());
 		List<String[]> collect1 = stringList.stream().map(s -> s.split("")).collect(Collectors.toList());
 webflux
 	reactive
 tomcat
 	连接模型

 PropertySource
 jconsul


bootstrap application
property source
属性覆盖 取值

bootstrap加载

cloud 2020  application.properties   ConfigDataEnvironmentPostProcessor

resilience4j  openfeign loadbanlancer 重试 超时时间
label
/actuator/refresh

LocatProperties   RefreshEvent
Spring Cloud Stream/Bus
Zipkin Sleuth
mybatis plus

配置改变，只初始化会改变值吗


explain

id   select_type   table  type  possib   key  key_len  ref  row filter  extra

相同自上而下，不同大的优先

SIMPLE
PRIMARY
SUBQUERY
DERIVED
UNION
UNION_RESULT

表的发生地

ALL 全表扫描
INDEX 全索引扫描
RANGE 索引范围扫描
REF 一般出现在join，对于前面的记录有多条匹配
EQ_REF 一般出现在join，驱动表只返回一条记录，且这条记录是第二个表的主键或者唯一索引，且必须为not null
CONST 主键/唯一索引,只返回一条记录
SYSTEM 特殊的CONST，表中只有一条记录

可能走的key

实际走的key

走的索引长度，char为  4n(urf8mb64编码集)   varchar 为4n+2(urf8mb64编码集)  可以为NULL额外加一个长度
tiny 1 SMALLINT 2  MEDIUMINT 3 int 4 bigint 8

过滤剩下的比率



Spring Cloud加载:2020版之前依赖bootstrap上下文和BootstrapConfig，之后依赖BootstrapContext(用完关闭)和Bootstrapper
	spring-cloud-context.jar
		META-INF/spring.factories
			org.springframework.context.ApplicationListener=org.springframework.cloud.bootstrap.BootstrapApplicationListener
	SpringApplication#run(class, args):
		new SpringApplication:
			SpringApplication#getSpringFactoriesInstances:ApplicationListener
				会去META-INF/spring.factories中找ApplicationListener实现类
			SpringApplication#setListeners:
				BootstrapApplicationListener implements ApplicationListener<ApplicationEnvironmentPreparedEvent>
		SpringApplication#run:
			SpringApplication#prepareEnvironment:
				SpringApplicationRunListeners#environmentPrepared:
					EventPublishingRunListener#environmentPrepared:
						SimpleApplicationEventMulticaster#multicastEvent:发布ApplicationEnvironmentPreparedEvent事件

			BootstrapApplicationListener#onApplicationEvent:
				BootstrapApplicationListener#bootstrapServiceContext:创建bootstrap上下文，设置parent
					SpringApplicationBuilder#run:
					BootstrapApplicationListener#addAncestorInitializer:
						BootstrapApplicationListener.AncestorInitializer#initialize:
							ParentContextApplicationContextInitializer#initialize:
								ConfigurableApplicationContext#setParent

   AbstractNestedCondition#matches:
      AbstractNestedCondition#getMatchOutcome
         AbstractNestedCondition.MemberConditions#getMemberConditions: 获取各个嵌套类的Condition
         AbstractNestedCondition.MemberMatchOutcomes#new
            AbstractNestedCondition.MemberConditions#getMatchOutcomes: 获取Condition匹配结果集(嵌套类纬度)
               AbstractNestedCondition.MemberOutcomes#getConditionOutcome:获取单个结果(嵌套类中单个Condition)
               AbstractNestedCondition.MemberOutcomes#getUltimateOutcome:获取最终匹配结果
         AbstractNestedCondition#getFinalMatchOutcome:根据规则返回结果(any/all)



面向对象编程

JVM
	空间分布
		堆
		栈
		元空间
	类加载
		加载  
		链接
			验证
			准备
			解析
		初始化
	GC垃圾回收
		回收算法
		垃圾回收器
Throwable
	Error
	Exception

final finally finalize
	fianl:
		class:
			该类不可继承，因此无法修改
			String为啥定义为final
		method:
			该方法不能被子类重写，可以用于保证框架内部行为不会改变
		variable:
			该引用不可修改，但引用指向的对象不受影响
			immutable   List.of   
			volatile
		标识意义大于性能意义，或许能略微提高性能

finally
	try-catch-finally:
		不管是否异常，都会处理finally块，通常用于释放资源
		try{
			// open resources
			resource = ...
		}catch(Exception e){
			// handle exception
		}finally{
			// close resources
			resource.close
		}
	try-with-resource:
		resource需要实现Closeable接口，这样可以自动关闭资源.   Closeable extends AutoCloseable
		try(resource)
	有几个特殊的例子:
		System.out()不会执行finally语句，因为JVM已经退出
		如果finally之前有return语句，则return会保存当前现场，执行完finally在返回。如果返回的是基本类型，然后在finally修改该返回值，虽然值修改了，但是返回值不变，因为当时保存了现场数据。如果是引用类型，则只会保存对象的引用，无法保证被引用的对象不被修改。

finalize:
	Object自带的方法，可以在垃圾收集时做一些操作，如释放资源， 但是不推荐使用(JDK9标为@Deprecated)，因为
	1.执行时间不确定，该方法由垃圾回收器调用，而垃圾回收的执行时间无法预知，如果程序终止之前都没有执行垃圾回收操作，那么该方法就不会掉用。显式调用System.gc()或Runtime.gc()方法可以促进垃圾回收的调用，但是不一定立即执行。
	2.性能很差，在垃圾回收前调用，会占用资源，并且延缓垃圾回收的执行
	3.finalize()方法有可能使对象复活，使它恢复到可触及状态
	4.垃圾回收器在执行finalize()方法时，如果出现异常，垃圾回收器不会报告异常，程序继续正常运行。
	代替方案:
		Cleaner:使用幻像引用操作


	克隆 序列化



	String final
	intern  11 111  
	引用 SoftReference WeakReference PhatmoReference  ReferenceQueue

	list copyandwritearraylist
	map hashmap concurrenthashmap
	juc

	DMA:

	Direact Buffer:
		堆外内存，不由jvm管理，地址一经确定不在改变
	Native Memory Tracking
	Zero Copy:
		设备->内核态->用户态->内核态->设备
		设备->内核态->设备

	volatier
	ReentrantLock

	retrelock
	synchronized


	锁的状态
	锁升级
	自旋锁
	AQS(AbstractQueuedSynchronizer)
	CAS(compare and swap)

	死锁

	互斥
	不可释放
	循环等待

	互斥导致的死循环，cpu占用率低，可通过jconsole，jstack排查
	死循环导致的死锁，cput占用率高，top查看高占用的pid，然后结合jstack排查


	AQS
	CAS
	Unsafe
	ReentrantLock

	类加载过程
		加载  
		链接
			验证
			准备
			解析  
		初始化

	加载器
		Boot
		Platform
		Application

	双亲委派

	动态代理
		动态生成字节码
		ASM
		CGLIB

	JVM
		程序计数器
		栈
			JVM栈
			本地方法栈
		堆
			包装类缓冲池
		元空间

		GC
			标记算法
				引用计数
				根可达
			回收算法
				复制
				标记-回收
				标记-整理
			垃圾收集器
				Serial
				Parnew
				CMS
				Parallel
				G1

				Serial Old


		happen-befor
		JMM

		docker限制jvm
		java安全 sql注入



		Autowired
			执行
		Resource
			顺序
		优先级
			AutowiredAnnotationBeanPostProcessor:Ordered.LOWEST_PRECEDENCE - 2
			CommonAnnotationBeanPostProcessor:Ordered.LOWEST_PRECEDENCE

		aop

		Aspect:
			PointCut
				ClassFilter
				MethodMatcher
			
			JoinPoint

			Adice
				BeforeAdvice
				AfterAdvice
					AfterAdvice
						AfterReturningAdvice
						AfterThrowingAdvice
				AroundAdvice

			Advice -AdvisedSupport-> Adivsor -AdvisorAdapter-> MethodInterceptor



Spring batch

	Job:Step 1:n

	Job: n
		JobInstance: n
			Job + JobParameters
			JobExecution: n
				JobInstance每执行一次会生成一个JobExecution，因为JobInstance可能失败，因此会有多个JobExecution

	Step: n 
		StepExecution


	ItemReader
	ItemProcesser
	ItemWriter

	JobRegistry

	JobLauncher


	BlockingQueue
		exception  return specialvalue
		add        offer
		remove     poll
		element    peek

	Executor
		ExecutorService
			AbstractExecutorService
				ThreadPoolExecutor:
					ThreadPoolExecutor#ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit, BlockingQueue workQueue, ThreadFactory, RejectedExecutionHandler)

				RejectedExecutionHandler:
					1.AbortPolicy(default):Always throws RejectedExecutionException. 
					2.DiscardPolicy:Does nothing, which has the effect of discarding task r.
					3.CallerRunsPolicy:Executes task r in the caller's thread, unless the executor has been shut down, in which case the task is discarded.
					4.DiscardOldestPolicy:Obtains and ignores the next task that the executor would otherwise execute, if one is immediately available, and then retries execution of task r, unless the executor is shut down, in which case task r is instead discarded.

		Executors#newSingleThreadExecutor():
			new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>()));
		Executors#newFixedThreadPool(int):
			new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
		Executors#newCachedThreadPool():
			new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());
		Executors#newScheduledThreadPool():
			new ScheduledThreadPoolExecutor(corePoolSize);
		Executors#newWorkStealingPool:
			new ForkJoinPool(parallelism, ForkJoinPool.defaultForkJoinWorkerThreadFactory, null, true);

			线程在任务提交时才会实例化，运行时抛出异常，则会销毁线程
		

		ForkJoinPool:把一个大任务拆成多个小任务并行执行。
		CompletableFuture:使用Future获得异步执行结果时，要么调用阻塞方法get()，要么轮询看isDone()是否为true，这两种方法都不是很好，因为主线程也会被迫等待。从Java 8开始引入了CompletableFuture，它针对Future做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。
		多个CompletableFuture可以串行执行,前者的输出可以作为后者的输入.


		JVM对象只在heap上?

		@ConfigurationProperties
			ConfigurationPropertiesBindingPostProcessor
			ConfigurationPropertiesBinder
			JavaBeanBinder

			EnvironmentChangeEvent
			ConfigurationPropertiesRebinder

		@RefreshScope:注入的是代理对象，代理对象指向targetBean，因此targetBean变化时，无需重新注入。
			BeanLifecycleWrapperCache

			每次获取时向缓存中放(putIfAbsent)值(ObjectFactory),之前取过bean，则继续取之前的，没有的话则通过ObjectFactory(createBean)获取
				更新时将缓存中的值删除掉，就重新取
			AbstractBeanFactory#doGetBean
				GenericScope#get


		Apollo:
			动态刷新:
				@Value
					支持。spring.factories中@EnableAutoConfiguration指向ApolloAutoConfiguration，ApolloAutoConfiguration添加ConfigPropertySourcesProcessor，
					AutoUpdateConfigChangeListener监听变化。

				@ConfigurationProperties
					暂不支持。可以通过ConfigService获取指定namespace的Config，然后添加监听器，当监听到配置变化时，发布EnvironmentChangeEvent事件，借助ConfigurationPropertiesRebinder(destroyBean,initializeBean,ConfigurationPropertiesBinder)完成对bean的刷新。



JAVA:
	面向对象
		封装，继承，多态
	跨平台
		源代码(.java) - javac -> 字节码(.class) - jvm -> 机器码。
		每个平台都有对应的JVM，因此可以跨平台执行。
	静态代码块，构造代码块，构造函数
	B extend A
	A静态代码块、B静态代码块、A构造代码块、A构造函数、B构造代码块、B构造函数
	类加载:
		1.加载: 根据类的全限定名将该类的字节码加载到内存，生成代表该类的Class对象
		2.链接:将创建好的Class对象合并到JVM
			验证:确保class文件中的字节码符合JVM的要求，确保类的正确性
			准备:为类的静态字段分配内存，并设置默认值。被final修饰的static字段不会设置，因为在编译时就分配了。
			解析:
		3.初始化:执行类的构造器方法init()的过程。这个方法不需要定义，是javac编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并来的。

		加载器:
			1.Bootstrap:加载Java核心类库。用C/C++语言实现的，因此获取不到相应信息。出于安全考虑，启动类只加载包名为：java、javax、sun开头的类。
			2.Platform:从系统属性：java.ext.dirs目录中加载类库，或者从JDK安装目录：jre/lib/ext目录下加载类库。我们就可以将我们自己的包放在以上目录下，就会自动加载进来了。
			3.Application:它负责加载环境变量classpath或者系统属性java.class.path指定路径下的类库。它是程序中默认的类加载器，我们Java程序中的类，都是由它加载完成的。

			双亲委派:资源隔离，可能造成资源冗余
				当类加载器接收到了类加载的请求，它自己不会先加载，而是让父加载器加载，如果父加载器也存在父类加载器则继续向上委托，一直到Bootstrap。父加载器加载失败时将由子类去尝试加载，如果加载失败，则抛出ClassNotFoundException异常。
	执行:
		将源码编译为字节码，然后JVM将字节码 解释 为机器码。
			这样启动的时候会很快，但是执行的时候会慢。
		编译器:
			将 源代码 转换成 机器语言，通常是 二进制形式(机器码) 并保存下来(复用)，等待执行。目的是生成 可执行的程序。
			优点:
				因为提前编译生成 机器码，所以直接执行 编译后的文件即可，因此速度较快。
			缺点:
				源代码编译后只能在该类机器上运行，无法跨平台。
		解释器:
			在程序运行时，将源代码转换为 机器语言(机器码)，并立即执行。
			工作模式:
				1.分析源代码，并且直接执行。
				2.把源代码翻译成相对更加高效率的中间码，然后立即执行它。
				3.执行由解释器内部的编译器预编译后保存的代码。
			优点:
				跨平台性，因为无需编译，因此只要解释器支持多平台，就有跨平台性。
			缺点:
				运行速度慢，解释器要额外的开销。

		为了提高运行效率，JAVA也提供了 直接编译为机器码的 机制。
			JIT(Just In Time): 即时编译器
				运行时，将热点代码的字节码 提前编译为机器码并保存下来，后续直接调用机器码，而无需解释执行，提高程序运行效率。
					热点代码:
						运行时，当某一方法调用次数达到即时编译定义的阈值时，可以将该方法认为 热点代码。
					编译器:
						C1编译器:client模式，根据1500次的收集计算出热点代码。启动性能好，适合启动快的客户端。
						C2编译器:server模式，根据10000次的收集计算出热点代码。峰值性能好，适合长期运行的服务端。
			AOT(Ahead-of-Time Compilation):
				运行之前，将应用中或JDK中的字节码编译成机器码(与即时编译器有区别)
		参数:
			-Xmixed:混合模式
			-Xint:解释
			-Xcomp:编译
			

	final/finally/finalize
		final:
			修饰类:不可继承
			修饰方法:不可重写
			修饰字段:不可重新赋值

			标识意义大于性能意义
		finally:
			try-catch-finally使用，确保代码一定会执行到
		finalize:
			在对象被回收前做一些特点的动作，如释放资源，但是不推荐使用。
			该方法由垃圾回收器在回收该对象前调用，调用时机无法预测，而且非空的finalize方法会导致相关的垃圾回收变慢，原本这个此次垃圾收集周期应该回收的对象，可能要多经过几次周期才能回收
			Cleaner


		immutable类实现注意事项:
			1.final修饰类
			2.字段用private final修饰
			3.如非必要，不提供getter方法，如果提供getter，则使用copy
			4.构造对象时，成员变量使用深克隆来初始化

	String 


	异常处理需要注意
细节问题

AOP Interceptor顺序
	BeanFactoryAspectJAdvisorsBuilder
	MethodInvocation
	ReflectiveMethodInvocation

引用
Strong Reference:
	强引用，平常创建对象时的引用，有强引用存在时，对象不会被回收，哪怕OOM(OutOfMemory)。
Soft Reference:
	软引用，比强引用弱一些，软引用指向的对象会在OOM前进行统一的回收，回收完如果还不够，则会OOM。
Weak Reference:
	弱引用，每次垃圾回收时都会进行回收，可以结合ReferenceQueue使用，这样对象在回收时可以在ReferenceQueue找到，使用弱引用获取对象并且用强引用指向会使对象复活。
Phantom Reference:
	幻影引用，每次垃圾回收时都会回收，通过幻影引用获取不到指向的对象，只能结合ReferenceQueue使用做一些回调机制。
Reference#reachabilityFence可以保持可达性，@since 9


String StringBuffer StringBuilder
intern 
immutable


代理
	反射:introspection
		运行时获取类和对象的信息，可以调用对象的方法
	字节码:asm，cglib
基本数据类型和包装类
	基本数据类型及大小
	基本数据类型线程不安全，i++
	包装类的职责，缓存范围
	包装类的value不可变
	对象大小
	泛型

	int 范围
有序集合
	Vector
	ArrayList
	LinkedList

	Collection
		List Set Queue

全局变量赋予局部变量
	相当于缓存，字节码会少一些
Map
Cas synchronization
同步异步/阻塞非阻塞
	 从进程级通信的维度讨论时， 阻塞和同步（非阻塞和异步）就是一对同义词， 且需要针对发送方和接收方作区分对待
		发送方阻塞:发送方进程会被一直阻塞， 直到消息被接收方进程收到
		发送方非阻塞:发送方进程调用 send() 后， 继续其他操作
		接收方阻塞:接收方调用 receive() 后一直阻塞， 直到消息抵达
		接收方非阻塞:接收方调用 receive() 函数， 要么得到有效消息， 要么得到空值， 不会被阻塞
	系统IO:
		用户态 -> 内核态 -> 硬件(数据准备阶段)
		阻塞非阻塞:
			用户态 -> 内核态，阻塞会一直等着内核态数据准备完成，非阻塞不会等内核态数据准备完成。因为从内核态复制到用户态的时间不能省去，因此属于同步
		同步异步:
			内核态 -> 硬件，异步什么时间也不用等，直接告诉系统数据放到哪里，然后内核态会在数据准备好之后将数据复制到指定位置。

		阻塞IO
		非阻塞IO
		IO复用
			reactor
		信号IO
		异步IO

DMA：
	直接内存访问，需要硬件支持。用户进程(用户态)没有权限执行IO操作，需要系统进程帮忙(内核态)，系统进程会操作CPU参与IO操作，这样CPU就不能做其他事情。
	DMA就不需要CPU参与，只需要CPU发送相关指令给DMA，DMA会负责IO操作，CPU就可以做其他事情。DMA需要硬件支持，需要硬件集成一个小型'CPU'。
RDMA：
	硬件和用户态内存(app buffer)直接交互。需要硬件和软件支持
zero copy:
	用户态(app buffer)->内核态(kernel)->用户态(app buffer)->内核态(缓存区)
	硬件<->内核态：DMA
	内核态<->用户态：CPU

			用户态
		内核态    内核态
	磁盘               网卡

	如果用户进程不对数据进行修改，完全可以不用做内核态和用户态的复制

频繁切换线程上下文是同步阻塞低扩展性的限制
LongAdder
AtomicInteger.getAndIncrement
	Unsafe#compareAndSet
	Unsafe#compareAndSwapInt

Atomic类:
	volatile保证可见性和有序性
	CAS保证原子性 Unsafe

文件复制:
	Stream
	Channel:在linux平台可能会用到zero-copy(零复制)
	java标准库:本地方法的用户态复制

	Buffer:
		capacity,limit,position,mark
		Direct Buffer:堆外
		MappedByteBuffer:将磁盘的文件内容映射到用户态的空间，程序可以直接操作数据

抽象类和接口:
	相同点:
		都不能直接使用
	不同点:
		抽象类是单继承的(extend)，接口可以是多实现(implement)，接口之间可以多继承
		抽象类可以单纯的标记为abstract class，没有抽象方法，但是接口必须要有
		抽象类可以有成员变量和具体方法，接口只能有静态常量(public static final)，不能有具体方法(JDK8开始支持default method)
		只有一个抽象方法的接口可以标记为@FunctionalInterface

面向对象:
	封装/继承/多态
	重写(方法名，参数，返回值必须相同)/重载(方法名和返回值相同，方法参数不同)
	原则:
		单一原则
		开闭原则
		里氏置换
		接口分离
		依赖倒置


postProcessProperties


org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver#getExceptionHandlerMethod
doResolveHandlerMethodException


DispatcherServlet
	FrameworkServlet
		HttpServletBean
			HttpServlet
				GenericServlet

@ExceptionHandler处理过程 v5.3.5
	HttpServletBean#init
		FrameworkServlet#initServletBean
			FrameworkServlet#initWebApplicationContext
				DispatcherServlet#onRefresh
					DispatcherServlet#initStrategies:
						DispatcherServlet#initHandlerExceptionResolvers:
							DispatcherServlet#getDefaultStrategies:HandlerExceptionResolver.class
								去DispatcherServlet.properties找对应实现。ExceptionHandlerExceptionResolver
								DispatcherServlet#createDefaultStrategy:
									AutowireCapableBeanFactory#createBean:
										ExceptionHandlerExceptionResolver#afterPropertiesSet:
											ExceptionHandlerExceptionResolver#initExceptionHandlerAdviceCache:查找@ControllerAdvice中的 @ExceptionHandler
												ControllerAdviceBean#findAnnotatedBeans:
													BeanFactoryUtils#beanNamesForTypeIncludingAncestors:Object.class
													ListableBeanFactory#findAnnotationOnBean:ControllerAdvice.class
												new ExceptionHandlerMethodResolver:
													MethodIntrospector#selectMethods:ExceptionHandler.class
													ExceptionHandlerMethodResolver#detectExceptionMappings:能处理的异常类型
													ExceptionHandlerMethodResolver#addExceptionMapping

	HttpServlet#service:
		FrameworkServlet#doGet:以get请求为例
			FrameworkServlet#processRequest:
				DispatcherServlet#doService:
					DispatcherServlet#doDispatch:
						DispatcherServlet#processDispatchResult:
							DispatcherServlet#processHandlerException:
								HandlerExceptionResolver#resolveException: ExceptionHandlerExceptionResolver
									AbstractHandlerMethodExceptionResolver#doResolveException:
										ExceptionHandlerExceptionResolver#doResolveHandlerMethodException:
											ExceptionHandlerExceptionResolver#getExceptionHandlerMethod:
												exceptionHandlerCache:@Controller本身含有的ExceptionHandler
													new ServletInvocableHandlerMethod
												exceptionHandlerAdviceCache:@ControllerAdvice所含有的ExceptionHandler
													new ServletInvocableHandlerMethod
											ServletInvocableHandlerMethod#invokeAndHandle:
												InvocableHandlerMethod#invokeForRequest:
													Method#invoke


DispatcherServlet#doService:



设计模式:
	工厂，单例，代理，委派
		单例:spring bean，BeanFactory层面唯一，如果是分层，当前查不到，则去父级查找

	构建型
	结构型
	行为型

synchronized和重入锁
	偏向锁和重入锁

锁的状态:
	无锁
	偏向锁:标识，记录获取锁的线程ID，如果相同线程来执行，则直接获取锁
	轻量级锁:CAS+自旋，适合同时并发不多的情况，可以在等待很短的时间内获取到锁
	重量级锁:操作系统的互斥锁，需要进行用户态到内核态的切换，因此开销很大。获取不到锁线程会阻塞挂起
并发并行:
	并发:同时发生，交替执行
	并行:同时运行，需要多CPU
ReentrantLock:
	可重入锁，以线程为单位，而不是以每次调用为单位，如果两个方法用的同一把锁，则在执行其中一个方法时可以不用重新获取直接执行另一个方法。泛指可重复可递归调用的锁，可以避免死锁。
ReadWriteLock:
	读写锁，读锁共享，写锁独占，两者互斥。悲观读
StampedLock:
	乐观读


加锁在try外面:
	如果加锁异常，则在finally释放锁时会抛出IllegalMonitorStateException，而且没有对应的异常处理，则异常信息会被生吞。

安全点Safe point

线程状态:
	NEW:new出来的状态
	RUNABLE:资源准备状态(CPU时间片/其他资源)，可能在等待资源，也可能在运行
	BLOKING:获取不到锁，阻塞
	WAITING:
	TIMED_WAIT:超时等待
	TERMINATED:意外退出或者正常结束
	同时调两次start()，会抛出IllelThreadStateException

	ThreadLocal：
		Thread -> ThreadLocalMap<WeakReference<ThreadLocal>, Object>
		ThreadLocalMap的key为弱引用，垃圾回收时扫描到就会回收，key变为null，但是value还存在，且无法访问，最好提前手动remove或者等线程销毁回收(线程池不会销毁线程，最好不要和ThreadLocal搭配使用)ThreadLocalMap，否则会出现内存泄漏。jdk为了最大程度避免内存泄漏，在get/set时会回收key为null对应的value.
死锁:
	互斥条件：一个资源每次只能被一个进程使用
	请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
	不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺
	循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系

	死锁时CPU占用不会特别高
	获取锁后进行死循环时，CPU占用较高

	jstack 打印栈信息，然后查找block或者wait，根据查找到的锁ID进行查找
	ThreadMXBean  ManagementFactory#getThreadMXBean
	ThreadMXBean#findDeadlockedThreads
	ThreadMXBean#getThreadInfo(long[])


	JUC各个数据结构及工具类
	锁
		ReentrantLock
		ReadWriteLock
		StampleLock
		锁条件
			Condition
	结构:
		CourrentHashMap
		AtomicInteger
		AddrLong
		BlokingQueue

		CopyOnWriteArrayList

	工具:
		CountDownLatch
			#countDown,#await,适合一个线程等其他线程工作完毕，不可恢复。
		CyclicBarrier
			#await,适合多个线程并行等待，可自动恢复。
		Semaphore
			#acquire,#release



	原理:
		volatile
		CAS
		AQS

有界/无界:
	队列有固定大小就是有界




Spring validator
	分组校验:
		@NotBlank(message="", groups = {clazz})
		Field

		@Validated({clazz})

	顺序校验(静态指定要校验的分组):
		@GroupSequence({clazz1, clazz2, 本身class})
		Class
			@NotBlank(message="")
			Field
			@NotBlank(message="", groups = {clazz1})
			Field
			@NotBlank(message="", groups = {clazz2})
			Field

		@Validated
		clazz1校验不通过，不会校验clazz2

	自定义顺序校验(动态指定要检验的分组):
		@GroupSequenceProvider
		Class
			DefaultGroupSequenceProvider#getValidationGroups:自定义要校验的分组，要包含需要校验的输入类本身，否则default分组就不会执行
 
9.28
	AQS / 类加载

	类加载:
		类加载的

9.29
	java 目录:/jre /jre/ext

10.8
	JVM内存分布:
			线程独占:
				程序计数器
					保存当前正在执行的指令地址
				栈
					虚拟机栈
					本地方法栈
						保存基本数据类型和对象的引用，单位栈帧，栈帧包括局部变量表，操作数栈，返回地址，动态链接，指向运行时常量池的引用

			线程共享:
				堆
					保存对象的实例，GC的主要工作地，JDK8及以后也放置intern缓冲池
				永久代
					JDK7及之前的，JDK8被移除。存放类元信息等，也存放intern缓冲池
				元空间
					JDK8及以后。存放类元信息，可自动改变大小
		逃逸分析
			判断哪些对象是可以存储在栈内存中而不用存储在堆内存中的，从而让其随着线程的消逝而消逝，进而减少了 GC 发生的频率，这也是常见的 JVM 优化技巧之一
		内存泄漏

git push <远程主机名> <本地分支名>:<远程分支名>
git branch -d (branchname)

工作区(workspace)  add  暂存区(index/stage)  commit 仓库(repository)   push  远程仓库(remote repository)
git reset：
	--mixed：默认，会重置暂存区和版本库(工作区文件和暂存区文件不会删除，需要重新add)
	--soft：会重置版本库(工作区文件和暂存区文件不会删除，需要重新commit)
	--hard：会重置暂存区和版本库，并且删除工作区，暂存区文件。

10.9
	查看JVM堆使用
	垃圾回收器
		Serial GC
		ParNewGC
		Parallel GC
		CMS
		G1

10.11
	G1:
		将堆分为大小相同的region，一般为2048个，可以自适应调整
		region逻辑上分为，Edon，Surivivor，Old，Humongous(可以看作Old，存放对象大于50%region的超大对象，对象非常大时会连续占用多块)
		Remebered Set:存放region中对象的引用关系，如老年代指向新生代的对象
		MinorGC  -> Concurrent Mark  -> MiexedGC
			MinorGC:回收新生代,复制算法
			Concurrent Mark:并发标记Old区域的对象
			MiexedGC:回收未被标记的对象，不包括Humongous区域，因为Humongous更加激进在MinorGC时会回收了，因为Humongous区域较少，通过查记录可以快速得知老年代有没有引用，新生代在MinorGC时也可知有没有引用，因此在MinorGC时就回收了。
	GC调优:
		确定调优目的，低延迟，高吞吐量，低内存占用
		查看当前GC的信息
		所选的垃圾回收器是否符合目的，符合的话，看局部情况，然后通过参数调整，多次尝试

10.12
	JMM:
		JMM就是Java内存模型(java memory model)	
			因为在不同的硬件生产商和不同的操作系统下，内存的访问有一定的差异，所以会造成相同的代码运行在不同的系统上会出现各种问题。所以JMM屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的并发效果。

		JMM规定所有的变量都存储在主内存中，包括实例变量，静态变量，但是不包括局部变量和方法参数。每个线程都有自己的工作内存，线程的工作内存保存了该线程用到的变量和主内存的副本拷贝，线程对变量的操作都在工作内存中进行。线程不能直接读写主内存中的变量。


		内存交互操作	
			线程  <-(use) 工作内存  <-(load) <-(read) 主内存 lock
			线程 <-> 工作内存 <-> 主内存
			线程  (assign)-> 工作内存  (store)-> (write)-> 主内存 unlock

		 	规则:
		 		不允许read、load、store、write操作之一单独出现，也就是read操作后必须load，store操作后必须write。
				不允许线程丢弃他最近的assign操作，即工作内存中的变量数据改变了之后，必须告知主存。
				不允许线程将没有assign的数据从工作内存同步到主内存。
				一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过load和assign操作。
				一个变量同一时间只能有一个线程对其进行lock操作。多次lock之后，必须执行相同次数unlock才可以解锁。
				如果对一个变量进行lock操作，会清空所有工作内存中此变量的值。在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值。
				如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量。
				一个线程对一个变量进行unlock操作之前，必须先把此变量同步回主内存。

		volatile：
			1.保证线程间变量的可见性。
				值更新后立刻同步到主内存，然后使其他线程中的缓存失效，使其重新读取值
			2.禁止CPU进行指令重排序。
				as-if-serial，不管怎么重排序，（单线程）程序的执行结果不能被改变。
				为了使指令更加符合CPU的执行特性，最大限度的发挥机器的性能，提高程序的执行效率，只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码逻辑顺序不一致，这个过程就叫做指令的重排序。
				重排序的种类分为三种，分别是：编译器重排序，指令级并行的重排序，内存系统重排序。

				volatile禁止指令重排序含义：
					当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见，在其后面的操作肯定还没有进行。
					在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。
				volatile禁止指令重排序原理：
					内存屏障：
						LoadLoad 屏障：对于这样的语句Load1，LoadLoad，Load2。在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。
						StoreStore屏障：对于这样的语句Store1， StoreStore， Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。
						LoadStore 屏障：对于这样的语句Load1， LoadStore，Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。
						StoreLoad 屏障：对于这样的语句Store1， StoreLoad，Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。

					在每个volatile读操作后插入LoadLoad屏障，在读操作后插入LoadStore屏障。
					在每个volatile写操作的前面插入一个StoreStore屏障，后面插入一个SotreLoad屏障。

			非线程安全的，因为无法保证原子性



	并发三要素:
		原子性
			原子性指的是一个操作是不可分割，不可中断的，一个线程在执行时不会被其他线程干扰。
		可见性
			可见性指当一个线程修改共享变量的值，其他线程能够立即知道被修改了。

			除了volatile关键字之外，final和synchronized也能实现可见性。
			synchronized的原理是，在执行完，进入unlock之前，必须将共享变量同步到主内存中。
			final修饰的字段，一旦初始化完成，如果没有对象逸出（指对象为初始化完成就可以被别的线程使用），那么对于其他线程都是可见的。
		有序性
			在Java中，可以使用synchronized或者volatile保证多线程之间操作的有序性。实现原理有些区别：

			volatile关键字是使用内存屏障达到禁止指令重排序，以保证有序性。
				volatile写之前加StoreStore，之后加StoreLoad
				volatile读之后加LoadLoad，LoadStore
			synchronized的原理是，一个线程lock之后，必须unlock后，其他线程才可以重新lock，使得被synchronized包住的代码块在多线程之间是串行执行的。

		AtomicLong:利用volatile(可见性，有序性) + CAS(UNSAFE，原子性)
			内部有volatile修饰的long，还有UNSAFE(用于底层操作，如CAS)

	Docker镜像结构:
		UnionFs(联合文件系统):是一种分层、轻量级并且高性能的文件系统，他支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。

		镜像由一层一层文件系统组层，这种层级的文件系统是UnionFs。
			bootfs(boot file system) 主要包含bootloader 和 kernel，bootloader 主要用于引导加载 kernel，当 kernel 被加载到内存中后 bootfs 会被 umount 掉。
			rootfs (root file system) 包含的就是典型 Linux 系统中的/dev，/proc，/bin，/etc 等标准目录和文件。

			不同的 linux 发行版（如 ubuntu 和 CentOS ) 在 rootfs 这一层会有所区别，体现发行版本的差异性。

10.13
	代码安全
		注入攻击，如SQL，XML
		DOS攻击，伪造大量哈希值相同的数据，使其发生大量碰撞
		加密解密
		权限鉴权
	服务器变慢
		如何排查
	lambda
		基准测试

10.14
	数据库隔离级别
	Spring生命周期和作用域

	Spring @Autowired时机
		AutowiredAnnotationBeanPostProcessor#postProcessProperties，和Properties一起处理
	Spring Bean 设置初始化方法
		@PostConstruct(CommonAnnotationBeanPostProcessor)
		InitializingBean#afterPropertiesSet
		@Bean(initMethod=)
	Spring Bean生成策略
		SimpleInstantiationStrategy利用反射获取构造器创建

	先被代理，后被异步代理:
		被代理的对象会 implement SpringProxy，Advised，DecoratingProxy
		AbstractAdvisingBeanPostProcessor#postProcessAfterInitialization:
			如果bean instanceof Advised
				就转换为Advised，然后把当前的Advisor加进去

10.22
	@Bean后标记@Order并不会影响被扫描的顺序，而是影响集合注入的顺序
	Spring事件，了解事件的含义，确定事件的监听体系，确保各个监听器不互相干扰。
	Spring Bean实现了AutoCloseable，在销毁时会自动调用close方法

	事件体系
10.25
	url解析匹配
	@RequestParam/@PathVariable
	类型转换，StringToNumberConverterFactory，@DataTimeFormat
	同名参数，绑定到数组，然后,分割

10.26
	Header，用MultiMap(header key区分大小写)，HTTPHeaders
	Context-Type
		Header Accept
		@RequestMapping(products)
	Conversion
		TypeConverter
10.27
	HttpMessageConversion
10.28
	@Valid
	ApplicationFilterChain

	Filter顺序问题:
		@Component   OrderedFilter
		FilterRegistrationBean
11.1
	Spring Security
	添加角色的方法，角色前缀
11.2
	ExceptionHandlerResolver 执行流程
	ExceptionHandlerResolver 和 HandlerMapping 注册逻辑
	@ConditionalOnClass
11.3
	RedisTemplate 序列化器
	Cassandro 副本 读取规则
	Cassandro 创建多个Session

	@Cacheable/@CacheEvit/@CachePut/@Caching
11.4
	事务 rollback=
	private方法修饰符 不支持事务
	事务传播级别 
		REQUIRE_NEW:两个事务互不影响
		NESTED(savepoint):本质上是同一个事务，嵌套事务通过savepoint实现，挂在外层事务上，因此外层事务回滚，嵌套事务也会滚。
11.5
	Request MultiValueMap
	Url参数 编码
	Url 避免多次编码
	@RequestParam
11.8
	@ImportResource(classpath):Indicates one or more resources containing bean definitions to import.
	@PropertySource:Annotation providing a convenient and declarative mechanism for adding a PropertySource to Spring's Environment
	@MockBean
11.9
	加载顺序
		Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class
	Spring AOP为什么只支持方法级别
	Filter顺序问题:
		@Component   OrderedFilter
		FilterRegistrationBean
11.10
	堆排序
	时间复杂度，空间复杂度
	Unicode规定了字符的映射规则，没有规定存储规则。汉字在UTF16中占两个字节
11.11
	时间复杂度，表示数据规模和执行所需时间的关系，常见有O(1),O(log n),O(n),O(nlog n),o(n2)。
		因为log 3 = log 3 2 * log 2 n。同理其他底的也可以换算，因此统称O(log n)。
		加法规则:
			相同规模的时间复杂度可以舍弃量级较小的时间复杂度，如O(n2 + n)，可以留作O(n2)
			不同规模的时间复杂度不可以舍弃，因为不知道哪个规模较小。如O(m + n)。
		乘法规则:
			需要保留。如O(n * n)，留作O(n2)。
		其他规则:
			因为系数，常量不影响 数据规模和执行所需时间的关系，因此可以省略
11.12
	最好时间复杂度
	最坏时间复杂度
	平均时间复杂度
	均摊时间复杂度

	数组满了就扩容(原来的两倍)，初始10
		最好:O(1)
		最坏:O(n)
			i正好为扩容的那次，扩容为原来的两倍
			10   +  20      + 40     + 80  + ... + i
			10(2^0) 10(2^1) 10(2^2)  10(2^3) ... 10(2^ log 2 i/10)
			等比数列求和: a1(1-q^n) / 1-q 
				代入: 10(1-2 * log 2 i/10) / -1 = 10 - n / -1 = n - 10，O(n)
		均摊:
			1 + i/(i - log 2 i/10), O(1)
		
11.15
	线性表：
		保存简单的前后节点关系。如数组，链表，队列，栈。
	非线性表：
		不是简单的前后节点关系。如二叉树，图。
	数组
		结构：
			线性表(简单的前后关系)，空间连续
		特点：
			用下标进行随机访问效率很高，因为用 首地址+要存取的下标*单位字节大小 就可以定位到内存地址。
			由于非尾部插入需要移动插入节点以后的数据，因此效率低，但是对于尾部添加，因为无需移动数据，因此效率也很高。
			如果数组对顺序没有要求，可以将党建要插入位置的节点移到尾部，然后插入节点。
			可以批量延迟删除。先标记，等位置不够了在清除。
	链表
		结构：
			线性表，空间不连续(使用索引指向后面的节点)
		特点：
			插入效率较高，因为无需移动数据，只需将要插入节点的索引进行修改即可。
			查询效率较低，因为空间不连续，需要遍历查找。
			只保存后续节点的叫单向链表，保持前后节点的叫双向链表。

	列表
		结构：
			线性表
		特点：
			对数组进行了封装，简化了操作(插入，动态扩容)，损耗了一点性能(不能保存基本类型，自动装箱拆箱)。
11.16
	数组实现LRU
	单链表的回文字符串
	单链表反转   1
	删除链表倒数第n个节点 1
	链表的中间节点  1
	两个有序链表合并  1
	链表中环检测
11.17
	栈：FILO
		结构：
			顺序栈：
				数组实现
			链式栈：
				链表实现
		类型：

	队列：FIFO
		结构：
			顺序队列：
				数组实现，有界
			链式队列：
				链表实现，无界
		类型：
			循环队列：解决数据搬移问题。
				队空条件:head = tail
				队满条件:(tail+1)%n=head
					tail指下一个元素应该插入的位置，为什么不能用head = tail来作为队满条件呢，如果队空条件会和队满条件一样，这样队空的时候也不能添加数据。(tail+1)%n=head会使队列内有一个空间不能存储数据。
			阻塞队列：适合生产者-消费者模型
			并发队列：适合多线程
11.18
	递归：
		出口条件
		规则
	排序：
		冒泡排序：
			相邻元素比较，按照规则交换
			稳定(相同元素不会交换顺序)，原地排序(空间复杂度O(1))，时间复杂度O(n^2)
		插入排序	
			每次从无序区取出元素然后比较，放入合适的位置，该位置之后的元素后移
			稳定(相同元素不会交换顺序)，原地排序(空间复杂度O(1))，时间复杂度O(n^2)
		选择排序
			从未排序的值中找出极值，放入对应位置
			不稳定(每次找到最小值会和对应下标的值交换)，原地排序(空间复杂度O(1))，时间复杂度O(n^2)

		有序度
		逆序度
11.19
	归并排序：
		递归+合并，将数组递归从中间分为两个子数组，直至子数组只含有一个元素，然后依次合并为有序数组
		稳定，非原地排序(O(n))，时间复杂的O(nlogn)
			4 2 0 1 5 3
			4 2 0 1  ｜      5 3
			4 2  ｜  0 1     5 ｜ 3
			4 ｜ 2    0 ｜ 1    3 5
			2 4   0 1   3 5
            0 1 2 4     3 5
            0 1 2 3 4 5
	分而治之思想
11.22
	快速排序：
		递归+分区，取一基准(通常为最后一个元素)，然后遍历数组，将小于基准的放入前面，大于基准的放入后面，然后对基准前面的数组和基准后面的数组分区，直到整个数组有序
		不稳定，原地排序(O(1))，时间复杂度(O(nlogn)，最坏O(n^2))
			4 2 0 1 5 3
			2 4 0 1 5 3
			2 0 4 1 5 3
			2 0 1 4 5 3
			2 0 1 3 5 4
			2 0 1 3   |  5  4
			3 0 1 2   |  4  5
			0 3 1 2   |  4  5
			0 1 3 2   |  4  5
			0 1 2 3   |  4  5

	有序数组快速排序时间
		1 2 3 4 5 6     n
		6 | 2 3 4 5 1   n - 1
		6 1 | 3 4 5 2   n - 2
		6 1 2 | 4 5 3   n - 3
		6 1 2 3 | 5 4   .
		6 1 2 3 4 | 5   .
		6 1 2 3 4 5     .

		n + n-1 + n-2 + ... + 1= (n + 1) / 2 * n = O(n^2) 

	第N大元素时间
		堆排序 O(K * logn)

	10个按时间戳排序的300M日志文件，如何在内存为1G的机器中合并排序
11.23
	线性排序：
		桶排序 O(n)
			根据数据值的范围划分几个桶，将数据均匀的分布在各个桶内，桶内使用快排或者其他排序算法，因为各个桶之间天然有序，所以遍历每个桶进行合并。
			如消费金额排序，每1000分为一个桶，如果分布不均匀，可以将数据量大的桶再次细化分桶，桶内排序后然后合并。
		计数排序 O(n)
			桶排序的变种，因为数据范围有限，所以每个值都划分为一个桶，然后遍历每个桶进行合并。
			如考试成绩排序，按照分数分为0-100，将分数放入对应的桶里，然后遍历合并。
		基数排序 O(n)
			将数据拆分，然后按照稳定排序，从最后一位依次排序。
			如电话号码排序，电话号码拆分为11位，高位天然大于地位，然后从最后一位开始排序，直到最高一位。

11.24
 	二分查找
 		有序数组(根据下标随机访问)。
 		mid的取值，范围条件，范围取值
 	链表二分查找时间复杂度
 	数的平方根，精确到小数后六位
11.25
	二分查找变形
		查找第一个等于该值
		查找最后一个等于该值
		查找第一个大于该值
		查找最后一个小于该值

	IP查找
	循环数组查找

	二叉树
11.26
	跳表
		每3个抽一个
11.29
	散列表
		哈希值为非负整数
		key相同，hash相同
		key不同，hash不同
	工业散列表要求
		快速查询，插入，删除
			要求哈希函数能均匀分布
			 >>>
		内存占用合理	
			负载因子，动态扩容
		极端情况下也能保持良好的性能
			哈希冲突解决方案
				开放寻址
					适合数据小
				链表
					适合数据大，链表可以用红黑树等结构提升性能
11.30
	散列表+链表:
		散列表定位位置，可以快速查找，添加，删除；链表可以快速顺序便利。
		结构:
			head data next(双向链表)
			hnext(存在散列表中链表(桶)的下一个节点)

	哈希算法
		MD5消息摘要算法,SHA安全散列算法。不同长度数据都会映射成定长数据。
		原理
			抽屉原理(引发哈希冲突)
		用途：
			数据唯一:
				唯一标识
				数据校验
			哈希取模:
				散列函数
				负载均衡
				分布式缓存
		
	对称算法
		DES,AES
	非对称算法
		RSA,ECC
12.1
	一致性哈希算法
		传统哈希算法在动态伸缩时会导致之前的映射规则失效，要解决此问题只能按新的映射规则移动原有的数据。
		而一致性哈希算法在动态伸缩时，可减少需要移动的数据。
			一致性哈希环，起点0，终点2^32 - 1。
				存放数据时，计算数据的hash值，范围为[0,2^32 - 1]，放入环中。
				放入机器时，根据IP或主机名计算hash值，也放入环中。
					将对象和服务器都放置到同一个哈希环后，在哈希环上顺时针查找距离这个对象的 hash 值最近的机器，即是这个对象所属的机器。
					添加机器时，只需要将上一个机器后面以及该机器前面的数据移动到该机器便可。
						当然，添加该机器只能缓解后一个机器的压力。

						可以使用虚拟节点来平坦所有机器的压力。
							将物理机按照性能分为多个虚拟节点，将虚拟节点放入环中，数据先找到虚拟节点，然后根据虚拟节点定位物理机。
	二叉树
		满二叉树
			一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树
		完全二叉树
			若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。
		高度，深度，层
			高度:从低到高，从0开始
			深度:从高到低
			层:高度+1
		深度遍历，广度遍历
			深度遍历
				前序遍历:根左右
				中序遍历:左根右
				后序遍历:左右根

	二叉遍历树:
		左子节点小于父节点
		右子节点大于父节点
12.2
	红黑树简介
12.3
	红黑树平衡规则
12.6
	递归树解递归函数时间复杂度:高度
		n
		  n/2
		     n/4
		        ...
		           1
		高度:n(1- (1/2) ^ n)/ 1 - 1/2

12.7
	细胞1小时分裂一次，3小时死亡，n小时后的细胞数量
	f(n) - f(n - 3)= f(1) + f(2) + f(3) + ...

	f(n) = 2f(n-1) - f(n-4)
	f(0) = 1
	f(-1) = 1
    时间 当前  增长  死亡  
	0  	1    0    0
	1  	2    1    0
	2  	4    2    0
	3  	7    4    1
	4  	13   7    1
	5  	24   13   2
	6   44   24   4   
	7   81   44   7
12.8
	堆排序
		堆属于完全二叉树，可以使用数组存放。
		堆的父节点要么大于等于左右子节点(大顶堆)，要么小于等于左右子节点(小顶堆)。
	应用
		优先队列：
			合并多个有序文件：
				从多个文件中分别取出第一个数据，放入到数组中，然后对数组进行堆排序(小顶堆)，将堆顶元素放入合并文件，然后从堆顶元素所在的文件中继续取出来一个入堆，依次反复，直至完成。
			定时器：
				将定时任务排序(小顶堆)，然后取出堆顶元素的触发时间计算出时间间隔，然后根据间隔时间去触发。
		topic：
			如果要取topic k条数据，可以创建大小为k的堆进行排序(小顶堆)。数据遍历完，堆中数据就是topic k数据。
		中位数(百分比数)：
			中位数是求在50%的数据。如果在n个数据中求中位数，按照50:50的比例可以创建一个n/2大小的大顶堆和一个n/2大小的小顶堆，这样大顶堆的堆顶元素就是中位数。
			添加新数据时，如果数据比大顶堆堆顶元素小，则将堆顶元素移入小顶堆，将新数据添加到大顶堆中，如果数据比大顶堆堆顶元素大，则将新数据添加到小顶堆中。注意保持两个堆的规模比例。
	思考
		对大规模数据取topic数据时，可以根据数据的hash取模将数据平摊到多个集合中，然后分别对集合进行topic，这样会得到多个topic数据，然后对多个topic数据进行topic。
12.9
	图
		有向图
		无向图
	存储结构
		邻接矩阵(二维数组):查找效率高，但浪费空间(会存储所有顶点信息)
		邻接表:节省空间，查找效率不高，可以将链表转换成红黑树，跳表来提升查找效率。
	广度搜索，深度搜索
12.10
	字符串匹配
	BF
		根据子字符串匹配，不匹配时，字符串后移一位匹配。
	RK
		利用hash，遍历一次便可知所有子字符串的hash，然后hash匹配。
			如小写字母匹配(0-25)。
				abcde 匹配cd(2 * 25^1 + 3 * 25^0)
				ab = 0 * 25^1 + 1 * 25^0
				bc = 1 * 25^1 + 2 * 25^0
				cd = 2 * 25^1 + 3 * 25^0
12.13
	BM
		坏字符规则
			坏字符对应模式串中的字符下标记为si，坏字符在模式串中找不到则xi记为-1，找得到则xi记为最后匹配的下标。
			字符串移动si-xi位
		好后缀规则
			从模式串后向前匹配，如果前面没匹配上，后缀匹配上了则记为好后缀{u}，在模式串中继续找{u}，找到了则将{u}对齐，找不到则将{u}拆为前缀和后缀继续匹配
12.14
	trie，字典树。适合前缀匹配。如搜索引擎关键字补全。
12.15
	AC自动机
12.16
	贪心算法
		分糖果
		找零钱
	Huffman编码：数据压缩
		前缀不重复、频率相关
		构建树:
			愿数据
				a(10) b(4) c(6) d(7) e(15)
			排序入队
				b(4) c(6) d(7) a(10) e(15)
			构建
										tem(42)
					           tem(27)				e(15)
                     tem(17)           a(10)
 				tem(10)      d(7)
 			b(4)     c(6)

12.17
	分治思想，分而治之。
	递归编程技巧。
12.20
	回溯算法
		八皇后，0-1背包。
12.21
	重学回溯算法
		八皇后，0-1背包，正则匹配。
12.22
	动态规划。
	0-1背包
12.23	
	贪心算法：在限制下找到期望值的最优解。
12.24
	并发
		分工，同步，互斥
		Future、Fork/Join
12.27
	可见行
		多核CPU，每个CPU都有自己的缓存。
	原子性
		CPU只能保证指令级别的原子性，不能保证编程语言的原子性
	顺序性
		编译器优化
	volatile
		内存屏障:Happens-Before几大规则
	互斥锁
12.28
	一个锁锁多个资源
	死锁
		互斥条件
		请求与保持条件
		不剥夺条件
		循环等待条件
12.29
	管程，monitor，MESA
	唤醒时条件满足，但是线程执行时可能又不满足了
		while(条件){
			wait();
		}
	尽量使用notifyAll
		如果线程1，2等待条件A，线程3，4等待条件B，线程1、2、3、4共用一个锁，
			2和4等待时，如果1使用notify唤醒4，那么4条件不满足继续等待，
				而1释放条件后，2还在阻塞
	JMM MESI 
		use  load read lock
		assign store write unlock
	操作系统线程生命周期
		初始状态 运行准备态 运行时 休眠状态 终止状态
	JAVA线程生命周期
		NEW RUNABLE(对应运行准备态/运行时) BLOCKED(休眠) WAIT(休眠) WAIT_TIME(休眠) TERMINAL(终止)
12.30
	局部变量，线程，调用栈，栈帧(参数，局部变量，返回地址)
	共享变量，封装(共享变量作为属性，提供统一访问方法，方法做好并发策略)，共享变量间的约束条件(共享变量间有关联)，并发策略(避免共享，不变模式，管程及同步工具)
12.31
	Lock 可重入锁，公平锁非公平锁
	更新对象的成员变量加锁，访问可变成员变量加锁，调用其他对象的方法时不加锁
	interreput:
		主动轮训
		被动通知，wait(),sleep()等方法需要捕获InterruptedException。当调用java.lang.Thread#interrupt时，阻塞的线程会被唤醒然后抛出InterruptedException，此时中断标识会被清空，需要手动调用java.lang.Thread#interrupt再次设置中断标识。
1.4
	StampedLock，
	CountDownLatch，CyclicBarrier
		CountDownLatch:一个线程等其他线程
		CyclicBarrier:多个线程互相等待。可以设置回调函数，回调函数由该回合最后一个调用await方法的线程执行，执行完才能进行下一轮。
1.5
	并发容器
		COW家族，Dequq双端队列
	原子类，乐观锁，CAS
1.6
	线程池
	Future，FutureTask
1.7
	CompletableFuture,CompletionStage
	CompletionService,ExecutorCompletionService
1.10
	Fork/Join
1.11
	Immutable模式(解决并发最简单的方法)，属性final修饰，只提供读方法。如果要提供修改方法，生成新对象。享元模式可以解决对象过多。
	COW，写时复制，延迟策略。
1.12
	ThreadLocal
	guarded suspension
	cron 表达式
1.13
	Balking
1.17
	分工模式
		Thread pre message:
			轻量级线程。Fiber
		Thread worker:
			线程池
		生产者-消费者模型:
			平衡生产者和消费者的速度差。适合批量数据处理(如数据库插数据)，分阶段提交。
1.18
	线程终止:
		二阶段终止模式:
			发送终止指令(设置标识位)。响应终止指令(while条件语句)。
			while(flag){
			   break;
			}
		毒丸:
			投入一个约定结束的任务，消费者执行到该任务时终止。
	优雅关闭线程:
		线程执行完run方法或者抛出异常结束。关闭线程可以设置标识位,注意处理interrupt。
		try{
			while(flag){
			   break;
			}
		} catch(InterruptedException e){
			Thread.currentThread().interrupt();
		}
	线程池关闭:
		shutdown:
			不接新任务，会把当前正在执行的任务和队列中的任务执行完。
		shutdownNow:
			不接新任务，会尝试中断所有正在执行的任务，剥夺队列中任务的执行机会，这些任务(中断+剥夺)会作为shutdownNow()方法的返回值返回。
				中断任务不一定成功，因为只有sleep,await,Condition情况下的线程会响应interrupt。
	Guava Ratelimit:

1.19
	Disruptor:
		CPU缓存，伪缓存，无锁(CAS)。
		伪缓存:
			CPU是按行缓存的(64字节)。同一个类的A，B字段都被CPU缓存了，然而一个线程对A进行修改时，会使A所在的缓存行失效，而B可能在该行内，所有B也会失效。解决办法，填充字节(会浪费空间)。
1.20
	HikariCP
		FirstList

		ConcurrentBag:
			CopyOnWriteArrayList<T> sharedList;共享队列
			ThreadLocal<List<Object>> threadList;本地线程持有列表
			AtomicInteger waiters;线程等待数
			SynchronousQueue<T> handoffQueue;线程分配器

			add
			borrow
			requite
1.21
	STM(Software Transaction Memory),MVCC
	协程
	
2.10
	JPA查询实体部分属性，可以创建一个interface，加上想要查询属性的get方法即可。

2.14
	Paas 打包难题  Docker镜像(提供完整的操作系统文件目录，本地环境和云环境高度一致)  Fig(Compose，编排) Swarm(集群管理能力)
2.15
	Kubernetes 容器编排技术 暴露各阶段API供操作(开发者友好)
	Cgroups资源限制，Namespace资源隔离
2.16
	Namespace共享内核，内核有很多资源不可Namespace化，如时间。如果容器修改了时间，宿主机的时间也会变。
	Cgroups Linux Controll Group(sys/fs/cgroup目录下查看)，/proc目录不知道Cgoups限制，top命令显示的是宿主机的数据。lxcfs
	容器，单进程模型，不能同时运行两个应用，可以找个公共程序充当父进程，如systemd/supervisord。但是如果子进程(应用进程)挂了，容器感知不到。不符合容器和应用进程同生共死的概念。
	Docker镜像  rootfs分层 只读层(核心文件) init层(hostname等) 读写层
	只读层ro+wh，读写层rw。init层是一些需要修改的只读层文件，但是提交时不需要提交(如hostname)，就单独的列出来了。提交时只提交读写层。如果需要修改只读层文件，在读写层做就可以了，文件在使用时会从上至下搜索，在读写层找到就返回了。
2.17
	Dockerfile 原语 build push commit exec(setns())      /proc/pid/ns
2.21
	Volumn bind mount
2.22
	kubernetes 编排 调度 brog  master(apiserver,schedule,controller) node kubelet CRI CNI CSI
	master控制中心 node计算中心 kubelet和容器交互 etc存储
	Pod Service Deployment Secrt
2.23
	kubeadmin kubelet宿主机，其他组件容器化 preflight checks
2.24
	stain/tolerate
2.25
	Volumns volumnMount
	EmptyDir HostPath
2.28
	Docker单进程模型，能启动多个进程，但无法管理多个进程
	Pod是逻辑概念，共享Network Namespace&Volumns，先启动一个Infra容器(200K)，然后Pod中的进程挂载到Infra的Network Namespace&Volumns。
3.1
	容器的本质是进程。容器设计模式sidecar，pod sidecar辅助容器，initContainer
	Pod属性，Nodeselect NodeName HostAliases
	container属性，Image ports volumemiunts imagepullpolicy Lifecycle

	Projected volume  Secret/ConfigMap/Downward Api/serviceAccountToken  
3.2
	ServiceAccountToken(Pod如果不指定，则会有一个默认的ServiceAccountToken，Volume:default-token-xxx) 
	Probe restart(重新创建) restartpolicy(Always/OnFailure/Never)
	Podpreset 多个合并，冲突放弃
	Pod如果允许restart，则一直是running。pod含多个容器时，所有容器异常时，pod状态才会变为faild

	kubernetes/pkg/controller可以看到所有的控制器，这是控制器模式，遵守控制循环control loop流程，完成自己的编排逻辑
	循环中通过比较实际情况和期望情况对pod做一些新增，删除，或者什么也不做。实际情况是k8s中当前pod的数量，期望情况是所有控制器中所设置的pod副本数
	控制循环，主动，轮训
3.3
	Deployment 副本数量，水平扩展，活动更新 restartPolicy:Always
	Deployment ResplicaSet Pod
	kubectl rollout status/undo/history
	kubectl edit 
	kubeneters API对象
	metadata: API对象通用属性
		lables
		annotation
	spec: API对象独有属性
		selector
	 		matchLable
3.7
	StatefulSet 
	拓扑状态  Headless Service
		Service
			Virtual IP
			Headless Service:     ClusterIp:None
				NormalService:Virtual IP
				DNS: podname.servicename.namespace.svc.cluster.local
		StatefulSet 严格按照编号顺序启动，以此保证拓扑顺序
	存储状态 
		PVC是声明，如果有对应的实现，可以直接使用，简化了开发人员对Volume编写。
		PV(Persistent Volume) PVC(Persistent Volume Claim)。每个pod都会挂载一个PV，而且PV编号和Pod编号一致。
3.8
	kubernetes mysql主从集群实践
		server-id
		bin-log   binary log dump Thread(主节点) I/O Thread(从节点) SQL Thread(从节点)
3.9
	StatefulSet是一个特殊的Deployment
	InitContainer先于containter启动，切按照顺序启动。containter启动顺序不固定，谁都可以先启动
	因为containter是单进程模型，且Pod共享network namespace和volume namespace，因此可以启动一个容器做sider辅助工作，需要注意的是容器之间启动顺序不固定
	做初始化操作时一定要考虑清楚重启是否有影响
3.10
	DaemonSet 会将Pod放到每一个node上，且只存在一个，节点扩展时会在新的Node上添加，收缩时会从移除的node上删除
	Daemon Controller会去etcd获取node信息，然后遍历，多则删除，少则添加。添加是通过NodeAffinity，daemon创建的pod会容忍污点，因此可以在任何一个node上创建
	DaemonSet 创建的pod一般用于网络或存储插件。当node有污点时，处于不可调度状态，普通的pod不会在该node上调度，但是daemon pod容忍污点，因此可以调度。
3.11
	BatchJob CronJob   batch/v1
	一次性作业(restartPolicy只能为Never/OnFailure)。restartPolicy:Never/Onfaiure。backofflimit指pod异常时最多尝试创建几次，activedeadlineseconds指Pod最多运行多久 。

	ln链接：可以理解为文件别名，一处修改处处修改	
		硬连接: ln source target
			1.以文件副本的形式存在，但不占实际空间(target显示的大小和source一致)
			2.source只能为文件
			3.只能同文件系统才能创建
		软连接: ln -s source target
			1.以路径的形式存在，target存的是source的地址
			2.可以跨文件系统
			3.可以对不存在的文件名进行链接
			4.source可以是文件，也可以是目录

			使用ls -l查看时，软链接target会指向source

	Docker 批量删除
		docker images | grep "none" | awk '{print $3}' | xargs docker rmi
3.15
	BatchJob
		spec.completions需要几个任务完成
		spec.parallelism并行数量
		WorkQueue任务分发

	声明式API (kubectl apply支持多个写操作同时进行，因为是PATCH) 
	 
	(Dynamic Adminssion Controller)  Initializer Istio的Initializer会在创建pod时添加envoy容器(merge)
3.16
	InitializerConfiguration 指定哪些对象需要初始化，会在新创建的这些对象metadata(lable/annotation)上添加initializer对象的名字，标识还未初始化，初始化后会去掉
3.21
	RBAC。Role、ClusterRole、RoleBinding 和 ClusterRoleBinding。ServiceAccount，Scret。
	Operator(控制器，根据编程做一些任务)。
		先创建CRD(custom resource definition)对象。
		然后Operator(控制器)在loop时控制CR对象。
	Operator statefulSet 可以协同工作
3.22
	PVC(Persistent Volume Claim)，PV(Persistent Volume)，Storeclass相同的PVC和PV才有可能Bind。
	Attach(挂载存储设备) Mount(将存储设备挂载到卷上)。
	Static Provision:由运维人员根据PVC一个一个创建PV
	Dynamic Provision:编写一个StoreClass，声明存储类型，存储插件。这样PVC声明时会找到对应的StoreClass，然后StoreClass创建PV。

	LPV 延迟绑定 （Static Provision）
3.23
	CSI 
		external components
			driver register:注册插件信息
			external provisioner:根据PVC创建PV
			external attacher:attach操作
		custom CSI
			CSI Identity:CSI相关信息
			CSI Controller:创建PV和attach操作
			CSI Node:mount操作
3.24
		基础网络环境构成:网卡 回环设备 路由表 iptables
		容器网络。Veth Pair网卡。拟网桥docker0。Overlay Network
		ARP(Address Resolution Protocol)。RARP(Reverse Address Resolution Protocol)。
3.28
	bgp  下一跳(将宿主机当作路由器)  将真正目的地mac封装到数据帧中
3.30
	Service DNS iptables ipvs
	ClusterIP Service 为pod提供固定的vip。Headless Service为pod提供固定的dns名字。
	Nodeport SNAT client访问哪个node就由哪个node回复。
	
	Nodeport宿主机映射。适合私有云。
	LoadBalancer负载均衡。适合公有云(都使用了CloudProvider的转接层)，调用CloudProvider在公有云创建一个负载均衡服务。
	ExternalName。添加CNAME记录。
4.11
	资源模型和资源管理。spec.containers.resources.requests/limits.cpu/memory。cpu单位m，1000m=1CPU。memory单位M(1000)/Mi(1024)。资源限制通过Cgroups实现。
	cpu是可压缩资源，资源不够时，pod会处于饥饿状态。memory是不可压缩资源，资源不够时，pod会被kill掉。
	QoS模型，同时设置limits和requests(单独设置limits相当与也设置了requests)，并且两者值相等的称为Guaranteed。只设置了requests被称为Burstable类型。都没设置称为BestEffort。当宿主机资源紧张时，k8s会对Pod进行Eviction(资源回收)，Eviction分为Soft和Hard，Soft允许你设置一段“优雅时间”，当资源不足超过这个时间段，kubelet才会开始Eviction。Hard会在达到阈值时直接触发
	Eviction会依次回收BestEffort、Burstable（饥饿的资源使用量超过requests）、Guaranteed（超过了limits/宿主机处于Memory Pressure）。宿主机处于Memory Pressure时会被打上污点，防止pod在调度在这上面。
4.15
	Priority   
		PriorityClass(不超过1billion，超出的为系统使用)。priorityClassNam.
	Preemption
		高优先级的pod调度失败后会抢占低优先级pod的资源，发生抢占时，低优先级的pod会被清理掉，因为删除pod调用DELETE API，所以有优雅停机时间，高优先级的pod不会立刻调度到低优先级所在的pod上，而是在对高优先级的pod设置nomitaedNodeName，等到下轮调度时在执行调度。当然，下轮调度会因为新增node或者其他pod被删除，导致pod不一定会调度到nomitaedNodeName指定的node。如果有更高优先级的pod，高优先级的nomitaedNodeName会被清理掉。
		acvtiveQ(存放正常调度的pod)，unschedulableQ(存放调度失败的pod)
4.16
	Spring AOP
		PointcutAdvisor
			PointCut:用于判断是否需要代理
				ClassFilter:类过滤器
				MethodMatcher:方法匹配器
			Advisor:增强的行为
				Advice -> AdvisedSupport -> Adivsor -> AdvisorAdapter -> MethodInterceptor
				Adice
					BeforeAdvice
					AfterAdvice
						AfterAdvice
							AfterReturningAdvice
							AfterThrowingAdvice
					AroundAdvice

		ProxyFactory#getProxy:
			AopProxyFactory#createAopProxy:
				JdkDynamicAopProxy
				ObjenesisCglibAopProxy

		AnnotationAwareAspectJAutoProxyCreator


		Aspect:
			PointCut
				ClassFilter
				MethodMatcher
			
			JoinPoint

			Adice
				BeforeAdvice
				AfterAdvice
					AfterAdvice
						AfterReturningAdvice
						AfterThrowingAdvice
				AroundAdvice

			

	Spring Boot 自动配置:
		在resouce目录下,创建META-INF/spring.factories文件，写入key-value键值对，key为EnableAutoConfiguration的全限定类名，value为要自动导入的类的全限定类名。被自动导入的类会被加载为一个Spring Bean处理。

	@Inherited，在类继承关系中，子类会继承父类中标记@Inherited的注解。
7.8
	并发编程：分工、同步、互斥
		分工：将任务合理分配给线程。Excecutor、ForkJoinPool
		同步：线程之间协作，如线程之间信号同步。wait()、notify()、notifyAll()、Semaphore、CountDownLatch、CyclicBarrier、Condition。
		互斥：对同一资源同一时刻只能一个线程访问。synchronized、Lock。
	并发问题：可见性、有序性、原子性
		可见性：数据的变化在线程间共享(针对CPU缓存问题)。
		有序性：防止指令重排序。
		原子性：一组CPU执行操作是不可分割，要么都执行，要么都不执行(高级编程语言中的一个指令可能对应多个CPU指令)。
		volatile可以保证可见性和有序性性。UnSafe CAS可以保证原子性。两者组合就是Atomic类。
7.13
	操作系统使用信号量解决并发问题，Java选择使用管程（Monitor）解决并发问题，具体实现是Synchronized。管程和信号量是等价的，可以使用管程实现信号量，也可以使用信号量实现管程。
	管程就是指管理共享变量，以及对共享变量的相关操作。具体到 Java 语言中，管程就是管理类的成员变量和方法，让这个类是线程安全的。管程的发展史中，先后出现过三种管程模型，Hasen 模型、Hoare 模型和 MESA 模型，Java 使用的是 MESA 模型，对应的实现是Synchronized。
	MESA解决互斥问题：
		将共享变量及对共享变量的操作统一封装起来，一次只允许一个线程访问(设置入口等待队列)。对应Synchronized(Object)。
	MESA解决同步问题：
		条件变量和条件变量等待队列。对应Object.wait、Object.notify。MESA 模型中，条件变量可以有多个，Java 语言内置的管程(Synchronized)里只有一个条件变量。Java SDK 并发包实现的管程(Lock)支持多个条件变量。
		编程范式，因为wait()被唤醒返回后是从wait()之后的代码开始执行，但是notify()唤醒时条件满足，wait()返回时条件可能又不满足，所以需要在检测一边。
		while(条件不满足){
			wait();
		}
	当T2的操作使T1的条件满足时，三个模型的通知方式不同：
		Hasen 模型：不中断T2，当T2执行完在唤醒T1。需要将notify放到代码最后。
		Hoare 模型：中断T2，唤醒T1，T1执行完在唤醒T2。相比于Hasen 模型多了一个唤醒操作，但是无需将notify放到代码最后。
		MESA 模型：不中断T2，当T1条件满足，将T1从条件变量等待队列放入入口等待队列。不保证T1一定能执行，因此wait方法支持超时参数。

9.13
	消息确认机制:
		生产者:
			事务模式(同步):阻塞的，一条消息没有发送完毕，不能发送下一条消息，它会榨干RabbitMQ服务器的性能。
				com.rabbitmq.client.Channel#txSelect
				com.rabbitmq.client.Channel#txCommit
				com.rabbitmq.client.Channel#txRollback
			Confirm模式(异步):
				单条确认:每发送一条消息后，调用waitForConfirms()方法，等待服务器端confirm。实际上是一种串行confirm了。
					com.rabbitmq.client.Channel#confirmSelect
					com.rabbitmq.client.Channel#waitForConfirms()
				批量确认:每发送一批消息后，调用waitForConfirms()方法，等待服务器端confirm。定期（每隔多少秒）或者定量（达到多少条）或者两则结合起来publish消息，然后等待服务器端confirm。一旦出现confirm返回false或者超时的情况时，客户端需要将这一批次的消息全部重发，这会带来明显的重复消息数量，并且，当消息经常丢失时，批量confirm性能应该是不升反降的。
					com.rabbitmq.client.Channel#confirmSelect
					com.rabbitmq.client.Channel#waitForConfirms()
				异步(回调)确认:提供一个回调方法，服务端confirm了一条或者多条消息后Client端会回调这个方法。回调方法参数只包含deliveryTag（当前Chanel发出的消息序号），我们需要自己为每一个Channel维护一个unconfirm的消息序号集合，每publish一条数据，集合中元素加1，每回调一次handleAck方法，unconfirm集合删掉相应的一条（multiple=false）或多条（multiple=true）记录。从程序运行效率上看，这个unconfirm集合最好采用有序集合SortedSet存储结构。
					com.rabbitmq.client.Channel#confirmSelect
					com.rabbitmq.client.Channel#addConfirmListener
					com.rabbitmq.client.Channel#getNextPublishSeqNo
			发送平均速率:
				事务模式（tx）：1637.484
				普通confirm模式(common)：1936.032
				批量confirm模式(batch)：10432.45
				异步confirm模式(async)：10542.06
		消费者:
			手动ACK

















问题整理：
1.什么是Spring
	Spring为现代Java企业应用程序提供了全面的编程和配置模型。Spring提供了IOC帮助我们配置以及管理bean，整合了各种框架为我们提供了开箱即用的功能。依赖查找/依赖注入，类型转换，数据绑定，事件，泛型等。
2.Spring模块
	spring-code：提供
	spring-beans：
	spring-context：
	spring-aop：
	spring-expression：
	spring-jdbc：
	spring-tx：
	spring-web：

3.Spring的优势和不足

1.什么是IoC容器
2.
3.
4.BeanFactory、FactoryBean和ObjectFactory
	BeanFactory：对象工厂，用于创建和管理对象。
	FactoryBean：工厂对象，用于创建复杂的对象。
	ObjectFactory：某个类型的对象工厂，延迟实例化对象。