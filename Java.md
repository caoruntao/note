# JAVA

## Java代码如何执行

### 执行方式

高级编程语言执行一般分为 编译 和 翻译两种执行方式。

#### 编译执行

​		将 源代码 转换成 机器语言，通常是 二进制形式(机器码) 并保存下来(复用)，等待执行。目的是生成 可执行的程序。
​		优点:
​			因为提前编译生成 机器码，所以直接执行 编译后的文件即可，因此速度较快。
​		缺点:
​			源代码编译后只能在该类机器上运行，无法跨平台。

#### 解释执行

​		在程序运行时，将源代码转换为 机器语言(机器码)，并立即执行。
​		工作模式:
​			1.分析源代码，并且直接执行。
​			2.把源代码翻译成相对更加高效率的中间码，然后立即执行它。
​			3.执行由解释器内部的编译器预编译后保存的代码。
​		优点:
​			跨平台性，因为无需编译，因此只要解释器支持多平台，就有跨平台性。
​		缺点:
​			运行速度慢，解释器要额外的开销。

### Java执行方式

源代码(.java) - javac -> 字节码(.class) - jvm -> 机器码。先通过javac编译为字节码(Java字节码指令被固定为一个字节)，执行时JVM将字节码解释为机器码(不同平台有对应的JVM，因此可以跨平台)。虚拟机另一个好处是带来一个托管环境(Managed Runtime)，可以帮我们处理一些代码冗余而且容易出错的部分，如内存管理和垃圾回收等。

运行时属于解释执行，为了提高运行效率(程序符合二八原则，20%的代码占用80%的资源)，JVM也提供了编译执行的方式。因此JVM属于混合执行，可通过JVM参数控制。

#### 编译执行机制		

###### JIT(Just In Time)

即时编译。运行时，以方法为单位，将频繁执行的热点代码编译为机器码保存起来(Code Cache，非堆区)，编译完成后(编译时还是以解释的方式执行，编译和解释执行可以并行)，后续调用则直接调用编译完成后的机器码，提高运行效率。

编译器:

​	C1:

​		client模式，将由1500次的收集计算出，启动性能好。

​	C2:

​		server模式，将根据10000次的收集计算出，峰值性能好。

​	Graal:

从Java7开始，HotSpot(JVM)默认采用分层编译的方式:热点方法先被C1编译，然后热点方法中的热点会被进一步被C2编译。为了不干扰应用的正常运行，即时编译是放在额外的编译线程中执行的。HotSpot会根据CPU的数据量设置编译线程的数据，并且按1:2的比例配置C1和C2的编译器。

理论上讲，即时编译后的Java程序的执行效率是可能超过C++的。这是因为和静态编译相比，即时编译拥有程序运行时信息，并且根据这个信息做出优化。

###### AOT(Ahead-of-Time Compilation)

运行之前，将应用中或JDK中的字节码编译成机器码(与即时编译器区别)



## 基本数据类型

Java语言中类型分为两大类，基本数据类型和引用类型。基本数据类型有八个，分别为boolean、byte、char、short、int、long、float、double。引用类型分为四种，分别为类、接口、数组、泛型，因为泛型是通过类型擦除(考虑到向后兼容)实现的，所有可以认为只存在前三种。

Java引入基本数据类型来支持数值计算，因为使用基本数据类型能够提高程序执行效率和减少内存占用。所有的计算操作都会被转换成整数运算。

| 类型    | 值域                 | 默认值   | 虚拟机内部符号 |
| ------- | -------------------- | -------- | -------------- |
| boolean | {false, true}        | false    | Z              |
| byte    | [-128, 128]          | 0        | B              |
| char    | [0, 65535]           | '\u0000' | C              |
| short   | [-32768, 32767]      | 0        | S              |
| int     | [-2^31, 2^31 - 1]    | 0        | I              |
| long    | [-2^63, 2^63 - 1]    | 0L       | J              |
| float   | ~[-3.4E38, 3.4E38]   | +0.0F    | F              |
| double  | ~[-1.8E308, 1.8E308] | +0.0D    | D              |

boolean在Java语言规范中使用true或false来表示，在JVM规范中，boolean会映射为int类型，true映射为1，false映射为0，编码规范约束了Java字节码的具体实现。

if(boolean) 会判断boolean是否为0，0就跳过。if(boolean == true)会判断boolean是否为1，不为1就跳过。



Java虚拟机每调用一个Java方法便会创建一个栈帧。在解释器的解释栈帧中，主要包括两个主要组成部分，分别是局部变量区()和字节码的操作数栈。这里的局部变量是广义的，除了普遍意义下的局部变量之外，它还包含实例方法的“this 指针”以及方法所接收的参数。

在 Java 虚拟机规范中，局部变量区等价于一个数组，并且可以用正整数来索引。除了 long、double 值需要用两个数组单元来存储之外，其他基本类型以及引用类型的值均占用一个数组单元。当然，这种情况仅存在于局部变量，而并不会出现在存储于堆中的字段或者数组元素上。

如将int类型的值存储到boolean类型时，为了保证堆中的 boolean 值是合法的，HotSpot 在存储时显式地进行掩码操作，也就是说，只取最后一位的值存入 boolean 字段或数组中。Java 虚拟机的算数运算几乎全部依赖于操作数栈。也就是说，我们需要将堆中的 boolean、byte、char 以及 short 加载到操作数栈上，而后将栈上的值当成 int 类型来运算。对于无符号类型，加载伴随着零扩展(高位补0)。对于有符号类型，加载伴随着符号扩展(类型值填充低字节，正数最高位补0，负数补1，其余全部补0)。

## Java类如何加载

### 类加载器

JDK8及之前

启动类加载器：加载最为基础、最为重要的类，如存放在JRE的lib目录下的jar包中的类(以及由虚拟机参数-Xbootclasspath指定的类)。由C++编写，在java代码中表现为null。

扩展类加载器：加载相对次要、但又通用的类，比如存放在JRE的lib\ext目录下jar包中的类(以及由系统变量java.ext.dirs指定的类)。

应用类加载器：负责加载应用程序路径下的类(指由虚拟机参数-cp/-classpath、系统环境变量java.class.path指定的路径)。默认情况下，应用程序中包含的类便是由应用类加载器加载的。

JDK9及现在(引入模块化)

启动类加载器：加载少数几个关键模块，如java.base。

平台类加载器：其他模块。

程序类加载器

### 双亲委派机制

每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。

提供了隔离机制，在 Java 虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。提供了安全机制，最核心的类(如String)由启动类加载器加载，不可被相同类名的文件破坏。

### 类加载过程

#### 加载：

​	根据类的全限定名将该类的字节码加载到内存，生成代表该类的Class对象

#### 链接：

​	将创建好的Class对象合并到JVM，使之能够执行的过程。

##### 验证：

​	确保被加载类能够满足 Java 虚拟机的约束条件。

##### 准备：

​	为被加载类的静态字段分配内存，并设置默认值。被final修饰的static字段不会设置，因为在编译时就分配了。

##### 解析：

​	将类成员的符号引用变成直接引用。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。）

#### 初始化：

​	执行类的构造器方法init()的过程。这个方法不需要定义，是javac编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并来的。



类加载时不一定会触发初始化，只用主动使用类时，才会触发，如

1. 当虚拟机启动时，初始化用户指定的主类；
2. 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；
3. 当遇到调用静态方法的指令时，初始化该静态方法所在的类；
4. 当遇到访问静态字段的指令时，初始化该静态字段所在的类；
5. 子类的初始化会触发父类的初始化；
6. 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；
7. 使用反射 API 对某个类进行反射调用时，初始化这个类；
8. 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。

## Java如何执行方法调用

### Java方法调用

#### 重载

在 Java 程序里，如果同一个类中出现多个名字相同，但参数类型不同的方法，我们称之为重载。

重载的方法在编译过程中即可完成识别。具体到每一个方法调用，Java 编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法。选取的过程共分为三个阶段：

1. 在不考虑对基本类型自动装拆箱（auto-boxing，auto-unboxing），以及可变长参数的情况下选取重载方法；
2. 如果在第 1 个阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；
3. 如果在第 2 个阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法。

如果 Java 编译器在同一个阶段中找到了多个适配的方法，那么它会在其中选择一个最为贴切的，而决定贴切程度的一个关键就是形式参数类型的继承关系。

除了同一个类中的方法，重载也可以作用于这个类所继承而来的方法。也就是说，如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型不同，那么在子类中，这两个方法同样构成了重载。

#### 重写

如果子类具有一个和父类非私有方法的方法名，方法参数，方法返回值(可以不一致，但是必须是返回值的子类)一致的方法，如果是非静态的方法可以认为子类重写了父类方法，如果是静态方法，可以认为子类中的方法会隐藏掉父类的方法。

众所周知，Java 是一门面向对象的编程语言，它的一个重要特性便是多态。而方法重写，正是多态最重要的一种体现方式：它允许子类在继承父类部分功能的同时，拥有自己独特的行为。

### JVM方法调用

Java 虚拟机识别方法的关键在于类名、方法名以及方法描述符（method descriptor）。方法描述符是由方法的参数类型以及返回类型所构成。在同一个类中，如果同时出现多个名字相同且描述符也相同的方法，那么 Java 虚拟机会在类的验证阶段报错。

#### JVM 的静态绑定和动态绑定

Java 虚拟机与 Java 语言不同，它并不限制名字与参数类型相同，但返回类型不同的方法出现在同一个类中，对于调用这些方法的字节码来说，由于字节码所附带的方法描述符包含了返回类型，因此 Java 虚拟机能够准确地识别目标方法。

Java 虚拟机中关于方法重写的判定同样基于方法描述符。也就是说，如果子类定义了与父类中非私有、非静态方法同名的方法，那么只有当这两个方法的参数类型以及返回类型一致，Java 虚拟机才会判定为重写。

对于 Java 语言中重写而 Java 虚拟机中非重写的情况，编译器会通过生成桥接方法来实现 Java 中的重写语义。

在某些文章中，重载也被称为静态绑定（static binding），或者编译时多态（compile-time polymorphism）；而重写则被称为动态绑定（dynamic binding）。Java 虚拟机中的静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。

Java 字节码中与调用相关的指令共有五种：

1. invokestatic：用于调用静态方法。
2. invokespecial：用于调用私有实例方法、构造器，以及使用 super 关键字调用父类的实例方法或构造器，和所实现接口的默认方法。
3. invokevirtual：用于调用非私有实例方法。
4. invokeinterface：用于调用接口方法。
5. invokedynamic：用于调用动态方法。

#### 调用指令的符号引用

​	在编译过程中，我们并不知道目标方法的具体内存地址。因此，Java 编译器会暂时用符号引用来表示该目标方法。这一符号引用包括目标方法所在的类或接口的名字，以及目标方法的方法名和方法描述符。

​	符号引用存储在 class 文件的常量池之中。根据目标方法是否为接口方法，这些引用可分为接口符号引用和非接口符号引用。在执行使用了符号引用的字节码前，Java 虚拟机需要解析这些符号引用，并替换为实际引用。

​	对于非接口符号引用，假定该符号引用所指向的类为 C，则 Java 虚拟机会按照如下步骤进行查找。

1. 在 C 中查找符合名字及描述符的方法。
2. 如果没有找到，在 C 的父类中继续搜索，直至 Object 类。
3. 如果没有找到，在 C 所直接实现或间接实现的接口中搜索，这一步搜索得到的目标方法必须是非私有、非静态的。并且，如果目标方法在间接实现的接口中，则需满足 C 与该接口之间没有其他符合条件的目标方法。如果有多个符合条件的目标方法，则任意返回其中一个。

​	从这个解析算法可以看出，静态方法也可以通过子类来调用。此外，子类的静态方法会隐藏（注意与重写区分）父类中的同名、同描述符的静态方法。

​	对于接口符号引用，假定该符号引用所指向的接口为 I，则 Java 虚拟机会按照如下步骤进行查找。

1. 在 I 中查找符合名字及描述符的方法。
2. 如果没有找到，在 Object 类中的公有实例方法中搜索。
3. 如果没有找到，则在 I 的超接口中搜索。这一步的搜索结果的要求与非接口符号引用步骤 3 的要求一致。

​	**经过上述的解析步骤之后，符号引用会被解析成实际引用。对于可以静态绑定的方法调用而言，实际引用是一个指向方法的指针。对于需要动态绑定的方法调用而言，实际引用则是一个方法表的索引。**

#### 虚方法调用

​	Java方法调用中的invokevirtual和invokeinterface指令属于Java虚拟机的虚方法调用。在绝大数情况下(除非方法被声明为final)，Java虚拟机需要根据调用者的动态类型来确定虚方法调用的目标方法，此过程称为动态绑定。相对于静态绑定的方法调用来说，动态绑定的方法调用更耗时。

​	Java方法调用中的invokestatic和invokespecial指令属于静态绑定。如果虚方法调用指向一个标记为 final 的方法，那么 Java 虚拟机也可以静态绑定该虚方法调用的目标方法。

#### 方法表

​	Java虚拟机采用了一种空间换时间的策略来实现动态绑定。它为每个类生成一张方法表(类加载阶段中的准备阶阶段创建)，来快速定位目标方法。	

​	方法表本质上是一个数组，里面存放当前类和祖先类中非私有的实例方法，这些方法可能是已经实现的方法，也可能是抽象方法。方法表满足两个特性，一是子类方法表中包含父类方法表中的所有方法，二是子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同。

​	我们知道，方法调用指令中的符号引用会在执行之前解析成实际引用。对于静态绑定的方法调用而言，实际引用将指向具体的目标方法。对于动态绑定的方法调用而言，实际引用则是方法表的索引值（实际上并不仅是索引值）。

​	实际上，使用了方法表的动态绑定与静态绑定相比，仅仅多出几个内存解引用操作：访问栈上的调用者，读取调用者的动态类型，读取该类型的方法表，读取方法表中某个索引值所对应的目标方法。相对于创建并初始化 Java 栈帧来说，这几个内存解引用操作的开销简直可以忽略不计。

​	方法表的动态绑定存在于解释执行中和即时编译的超多态情况。

#### 内联缓存

​	内联缓存是一种加快动态绑定的优化技术。它能够缓存调用者的动态类型，以及该类型所对应的目标方法，以后执行时，如果碰到已缓存的类型，内联缓存便会直接调用该类型所对应的目标方法。如果没有碰到缓存类型，则会退化为方法表的动态绑定。

​	在针对多态的优化手段中，我们通常会提及以下三个术语。

 	1. 单态（monomorphic）指的是仅有一种状态的情况。
 	2. 多态（polymorphic）指的是有限数量种状态的情况。二态（bimorphic）是多态的其中一种。
 	3. 超多态（megamorphic）指的是更多种状态的情况。通常我们用一个具体数值来区分多态和超多态。在这个数值之下，我们称之为多态。否则，我们称之为超多态。

​	单态内联缓存，顾名思义，便是只缓存了一种动态类型以及它所对应的目标方法。它的实现非常简单：比较所缓存的动态类型，如果命中，则直接调用对应的目标方法。

​	多态内联缓存则缓存了多个动态类型及其目标方法。它需要逐个将所缓存的动态类型与当前动态类型进行比较，如果命中，则调用对应的目标方法。

​	超多态内联缓存则放弃了优化的机会，它将直接访问方法表，来动态绑定目标方法。

为了节省内存空间，Java 虚拟机只采用单态内联缓存。当内联缓存没有命中时，Java虚拟机则劣化为超多态状态，将直接访问方法表，来动态绑定目标方法。

​	虽然内联缓存附带内联二字，但是它并没有内联目标方法。这里需要明确的是，任何方法调用除非被内联，否则都会有固定开销。这些开销来源于保存程序在该方法中的执行位置，以及新建、压入和弹出新方法所使用的栈帧。对于极其简单的方法而言，比如说 getter/setter，这部分固定开销占据的 CPU 时间甚至超过了方法本身。此外，在即时编译中，方法内联不仅仅能够消除方法调用的固定开销，而且还增加了进一步优化的可能性。



## Java如何处理异常

异常处理的两大组成元素是抛出异常和捕获异常。这两大要素共同实现程序控制流的非正常转移。

### 抛出异常

​	抛出异常可分为显式和隐式。显式抛出是指应用程序使用 throw 关键字手动将异常实例抛出。隐式抛出是指Java虚拟机在执行过程中，碰到无法继续执行的异常状态时自动抛出。

### 捕获异常

​	捕获异常则涉及了如下三种代码块：

	1. try 代码块：用来标记需要进行异常监控的代码。
	1. catch 代码块：跟在 try 代码块之后，用来捕获在 try 代码块中触发的某种指定类型的异常。除了声明所捕获异常的类型之外，catch 代码块还定义了针对该异常类型的异常处理器。在 Java 中，try 代码块后面可以跟着多个 catch 代码块，来捕获不同类型的异常。Java 虚拟机会从上至下匹配异常处理器。因此，前面的 catch 代码块所捕获的异常类型不能覆盖后边的，否则编译器会报错。
	1. finally代码块：跟在try代码块和catch代码块后，用来声明一段必须执行的代码。设计的初衷是为了避免跳过某些关键的清理代码，如关闭一些打开的系统资源。

​	在程序正常执行后，会调用finally代码块。否则会在catch 代码块捕获并处理过异常后调用。如果catch没有捕获到异常，则直接执行finally代码块然后继续抛出该异常。如果catch 代码块也抛出异常，finally代码块运行后会继续抛出该异常。最糟糕的情况是finally代码块也遇到异常，此时中断执行，并往外抛出异常。

### 异常的基本概念

​	在Java规范中，所有异常都是Throwable类或者其子类的实例。Throwable由两大直接子类。第一个是Error，涵盖程序不该捕获的异常，当程序触发Error时，它的执行状态已经无法恢复，需要中止线程甚至中止虚拟机。第二个是Exception，涵盖可能需要捕获并且处理的异常。Exception有一个特殊的子类RuntimeException，用来表示程序虽然无法继续执行，但是还能抢救一下。

​	Error和RuntimeException属于非检查异常(unchecked exception)，其他异常属于检查异常(checked exception)。检查异常需要在程序中显式的捕获，或者在方法中标记throws关键字，抛到调用者去处理。

​	异常实例的构造十分昂贵。由于构造异常实例时，Java虚拟机需要生成该异常的栈轨迹(stack trace)。该操作会一一访问当前线程的Java栈帧，并记录下各种调式信息，包括栈帧指向的方法名、类名、以及触发的位置。

### Java虚拟机捕获异常

​	在编译生成的字节码中，每个方法都有一个异常表。表中的每条记录都代表一个异常处理器，记录中包括from指针、to指针、target指针和捕获的异常类型。这些指针的值时字节码索引，用以定位字节码。

​	其中form指针和to指针标示了该异常处理器监控的范围，如try代码块覆盖的范围。target指针指向异常处理器的起始位置，如catch代码块的起始位置。

​	当程序触发异常时，Java 虚拟机会从上至下遍历异常表中的所有条目。当触发异常的字节码的索引值在某个异常表条目的监控范围内，Java 虚拟机会判断所抛出的异常和该条目想要捕获的异常是否匹配。

​	finally 代码块的编译比较复杂。当前版本 Java 编译器的做法，是复制 finally 代码块的内容，分别放在 try-catch 代码块所有正常执行路径以及异常执行路径的出口中。



如果 catch 代码块捕获了异常，并且触发了另一个异常，那么 finally 捕获并且重抛的异常是哪个呢？答案是后者。也就是说原本的异常便会被忽略掉，这对于代码调试来说十分不利。

### Java7的Suppressed异常以及语法糖

​	Java7引入Suppressed异常来解决原本的异常被忽略掉的问题。这个特性允许将一个异常依附于另一个异常上，因此，抛出的异常可以附带多个异常信息。然而Java层面的finally代码块缺少指向所捕获的异常的引用(catch代码块可以声明异常，finally代码块不可以)，所以这个特性使用起来非常繁琐。

​	为此，Java7专门构建了一个try-with-resources 的语法糖，在字节码层面自动使用Suppressed异常。当然，该语法糖的主要目的并不是使用 Suppressed 异常，而是精简资源打开关闭的用法。

​	try-with-resources 语法糖允许在 try 关键字后声明并实例化实现了 AutoCloseable 接口的类，编译器将自动添加对应的 close() 操作。与手工代码调用close()操作相比，try-with-resources 还会使用 Suppressed 异常的功能，来避免原异常“被消失”。

​	除了 try-with-resources 语法糖之外，Java 7 还支持在同一 catch 代码块中捕获多种异常。实际实现非常简单，生成多个异常表条目即可。

## Java处理反射

### 反射 	

​	Reflection(反射) 是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序对自身进行检查。通过反射，我们可以在运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。

#### 功能

Java 反射主要提供以下功能：

- 在运行时判断任意一个对象所属的类；
- 在运行时构造任意一个类的对象；
- 在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；
- 在运行时调用任意一个对象的方法

#### 运用

​	Java反射的基本运用:

	+ 获得 Class 对象。有三种方式，Class.forName("类名") 、对象.getClass() 、int.class。
	+ 判断是否为某个类的实例。instanceof关键字或者Class.对象的isInstance()方法。
	+ 创建实例。使用Class对象的newInstance()方法来创建Class对象对应类的实例。或者先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。
	+ 获取方法。`getDeclaredMethods` 方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。`getMethods` 方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。
	+ 获取类的成员变量（字段）信息。`getFiled`：访问公有的成员变量。`getDeclaredField`：所有已声明的成员变量，但不能得到其父类的成员变量
	+ 调用方法。Method.invoke
	+ 利用反射创建数组。Array.newInstance(Class<?>,int)

### 反射调用实现

​	方法的反射调用通过Method.invoke实现，方法执行时会委派给MethodAccessor执行。MethodAccessor 是一个接口，它有两个已有的具体实现：一个通过本地方法来实现反射调用，另一个则使用了委派模式。每个 Method 实例的第一次反射调用都会生成一个委派实现，它所委派的具体实现便是一个本地实现(C++调用)。

~~~java
    public Object invoke(Object obj, Object... args)
        throws IllegalAccessException, IllegalArgumentException,
           InvocationTargetException
    {
        if (!override) {
            Class<?> caller = Reflection.getCallerClass();
            checkAccess(caller, clazz,
                        Modifier.isStatic(modifiers) ? null : obj.getClass(),
                        modifiers);
        }
        MethodAccessor ma = methodAccessor;             // read volatile
        if (ma == null) {
            ma = acquireMethodAccessor();
        }
        return ma.invoke(obj, args);
    }
~~~

​	反射调用先是调用了 Method.invoke，然后进入委派实现（DelegatingMethodAccessorImpl），再然后进入本地实现（NativeMethodAccessorImpl），最后到达目标方法。

​	Java 的反射调用机制还设立了另一种动态生成字节码的实现（下称动态实现），直接使用 invoke 指令来调用目标方法。之所以采用委派实现，便是为了能够在本地实现以及动态实现中切换。

~~~java
// 动态实现的伪代码，这里只列举了关键的调用逻辑，其实它还包括调用者检测、参数检测的字节码。
// 生成直接调用方法的Java代码，和平时写的方法调用一样
package jdk.internal.reflect;
public class GeneratedMethodAccessor1 extends ... { 
    @Overrides 
    public Object invoke(Object obj, Object[] args) throws ... { 
    	Test.target((int) args[0]); 
        return null; 
    }
}
~~~

​	动态实现和本地实现相比，其运行效率要快上 20 倍  。这是因为动态实现无需经过 Java 到 C++ 再到 Java 的切换，但由于生成字节码十分耗时，仅调用一次的话，反而是本地实现要快上 3 到 4 倍 。

​	考虑到许多反射调用仅会执行一次，Java 虚拟机设置了一个阈值 15（可以通过 -Dsun.reflect.inflationThreshold= 来调整），当某个反射调用的调用次数在 15 之下时，采用本地实现；当达到 15 时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现，这个过程我们称之为 Inflation。反射调用的 Inflation 机制是可以通过参数（-Dsun.reflect.noInflation=true）来关闭的。这样一来，在反射调用一开始便会直接生成动态实现，而不会使用委派实现或者本地实现。

### 反射调用开销

​	反射调用涉及到Class.forName，Class.getMethod 以及 Method.invoke 三个操作。其中，Class.forName 会调用本地方法，Class.getMethod 则会遍历该类的公有方法。如果没有匹配到，它还将遍历父类的公有方法。以 getMethod 为代表的查找方法操作，会返回查找得到结果的一份拷贝，将带来额外的堆空间消耗。

​	方法的反射调用会带来不少性能开销，原因主要有三个：变长参数方法导致的 Object 数组(Method.invoke是个变长参数)	，基本类型的自动装箱、拆箱，还有最重要的方法内联。

## JVM实现invokedynamic

​	在 Java 中，方法调用会被编译为 invokestatic，invokespecial，invokevirtual 以及 invokeinterface 四种指令。这些指令与包含目标方法类名、方法名以及方法描述符的符号引用捆绑。在实际运行之前，Java 虚拟机将根据这个符号引用链接到具体的目标方法。在这四种调用指令中，Java 虚拟机明确要求方法调用需要提供目标方法的类名。

​	Java 7 引入了一条新的指令 invokedynamic。该指令的调用机制抽象出调用点这一个概念，并允许应用程序将调用点链接至任意符合条件的方法上。 invokedynamic的实现基于方法句柄（MethodHandle）。

​	方法句柄是一个强类型的、能够被直接执行的引用。它仅关心所指向方法的参数类型以及返回类型，而不关心方法所在的类以及方法名。方法句柄的权限检查发生在创建过程中，相较于反射调用节省了调用时反复权限检查的开销。

​	方法句柄可以通过 invokeExact 以及 invoke 来调用。其中，invokeExact 要求传入的参数和所指向方法的描述符严格匹配。方法句柄还支持增删改参数的操作，这些操作是通过生成另一个充当适配器的方法句柄来实现的。

​	方法句柄可以通过 invokeExact 以及 invoke 来调用。其中，invokeExact 要求传入的参数和所指向方法的描述符严格匹配。方法句柄还支持增删改参数的操作，这些操作是通过生成另一个充当适配器的方法句柄来实现的。

​	invokedymaic 指令抽象出调用点的概念，并且将调用该调用点所链接的方法句柄。在第一次执行 invokedynamic 指令时，Java 虚拟机将执行它所对应的启动方法，生成并且绑定一个调用点。之后如果再次执行该指令，Java 虚拟机则直接调用已经绑定了的调用点所链接的方法。

​	Lambda 表达式到函数式接口的转换是通过 invokedynamic 指令来实现的。该 invokedynamic 指令对应的启动方法将通过 ASM 生成一个适配器类。对于没有捕获其他变量的 Lambda 表达式，该 invokedynamic 指令始终返回同一个适配器类的实例。对于捕获了其他变量的 Lambda 表达式，每次执行 invokedynamic 指令将新建一个适配器类实例。

​	不管是捕获型的还是未捕获型的 Lambda 表达式，它们的性能上限皆可以达到直接调用的性能。其中，捕获型 Lambda 表达式借助了即时编译器中的逃逸分析，来避免实际的新建适配器类实例的操作。




	lambda
	 	peek:
	 		Consumer，无返回值，因此返回的Stream和之前的Stream一样。但是修改Stream中元素对象的属性，对象还是会发生变化的
	 	map:
	 		Function，有返回值，因此返回的Stream就是你的返回值组成的Stream。同时修改Stream中元素对象的属性，对象也会发生变化的。
	 	flatmap:
	 		将元素铺平(如Array)。如果你想将一个String，分割为一个个字符，但是你又不想接收一个Array<String>，那么你可以用flatmap，该方法会将Array的各个元素取出铺平。
	 		List<String> collect = stringList.stream().flatMap(s -> Arrays.stream(s.split(""))).collect(Collectors.toList());
	 		List<String[]> collect1 = stringList.stream().map(s -> s.split("")).collect(Collectors.toList());
	
	获取类的方法：
		Class.forName()
		类名.class
		实例.getClass()
	
	线程池执行流程：
		先看当前线程数是否小于corePoolSize
			如果小于则新建线程执行该任务。
			如果不小于，则看是否可以加入任务队列
				如果可以加入，就加入到任务队列
				如果不可以加入，则看当前线程数是否小于maximumPoolSize：
					如果小于则新建线程执行任务
					如果不小于，则选择拒绝策略

