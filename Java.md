

# JAVA

## Java代码如何执行

### 执行方式

高级编程语言执行一般分为 编译 和 翻译两种执行方式。

#### 编译执行

​		将 源代码 转换成 机器语言，通常是 二进制形式(机器码) 并保存下来(复用)，等待执行。目的是生成 可执行的程序。
​		优点:
​			因为提前编译生成 机器码，所以直接执行 编译后的文件即可，因此速度较快。
​		缺点:
​			源代码编译后只能在该类机器上运行，无法跨平台。

#### 解释执行

​		在程序运行时，将源代码转换为 机器语言(机器码)，并立即执行。
​		工作模式:
​			1.分析源代码，并且直接执行。
​			2.把源代码翻译成相对更加高效率的中间码，然后立即执行它。
​			3.执行由解释器内部的编译器预编译后保存的代码。
​		优点:
​			跨平台性，因为无需编译，因此只要解释器支持多平台，就有跨平台性。
​		缺点:
​			运行速度慢，解释器要额外的开销。

### Java执行方式

源代码(.java) - javac -> 字节码(.class) - jvm -> 机器码。先通过javac编译为字节码(Java字节码指令被固定为一个字节)，执行时JVM将字节码解释为机器码(不同平台有对应的JVM，因此可以跨平台)。虚拟机另一个好处是带来一个托管环境(Managed Runtime)，可以帮我们处理一些代码冗余而且容易出错的部分，如内存管理和垃圾回收等。

运行时属于解释执行，为了提高运行效率(程序符合二八原则，20%的代码占用80%的资源)，JVM也提供了编译执行的方式。因此JVM属于混合执行，可通过JVM参数控制。

#### 编译执行机制		

###### JIT(Just In Time)

即时编译。运行时，以方法为单位，将频繁执行的热点代码编译为机器码保存起来(Code Cache，非堆区)，编译完成后(编译时还是以解释的方式执行，编译和解释执行可以并行)，后续调用则直接调用编译完成后的机器码，提高运行效率。

编译器:

​	C1:

​		client模式，将由1500次的收集计算出，启动性能好。

​	C2:

​		server模式，将根据10000次的收集计算出，峰值性能好。

​	Graal:

从Java7开始，HotSpot(JVM)默认采用分层编译的方式:热点方法先被C1编译，然后热点方法中的热点会被进一步被C2编译。为了不干扰应用的正常运行，即时编译是放在额外的编译线程中执行的。HotSpot会根据CPU的数据量设置编译线程的数据，并且按1:2的比例配置C1和C2的编译器。

理论上讲，即时编译后的Java程序的执行效率是可能超过C++的。这是因为和静态编译相比，即时编译拥有程序运行时信息，并且根据这个信息做出优化。

###### AOT(Ahead-of-Time Compilation)

运行之前，将应用中或JDK中的字节码编译成机器码(与即时编译器区别)



## 数据类型

Java语言中类型分为两大类，基本数据类型和引用类型。基本数据类型有八个，分别为boolean、byte、char、short、int、long、float、double。引用类型分为四种，分别为类、接口、数组、泛型，因为泛型是通过类型擦除(考虑到向后兼容)实现的，所有可以认为只存在前三种。

Java引入基本数据类型来支持数值计算，因为使用基本数据类型能够提高程序执行效率和减少内存占用。所有的计算操作都会被转换成整数运算。

| 类型    | 值域                 | 默认值   | 虚拟机内部符号 |
| ------- | -------------------- | -------- | -------------- |
| boolean | {false, true}        | false    | Z              |
| byte    | [-128, 128]          | 0        | B              |
| char    | [0, 65535]           | '\u0000' | C              |
| short   | [-32768, 32767]      | 0        | S              |
| int     | [-2^31, 2^31 - 1]    | 0        | I              |
| long    | [-2^63, 2^63 - 1]    | 0L       | J              |
| float   | ~[-3.4E38, 3.4E38]   | +0.0F    | F              |
| double  | ~[-1.8E308, 1.8E308] | +0.0D    | D              |

boolean在Java语言规范中使用true或false来表示，在JVM规范中，boolean会映射为int类型，true映射为1，false映射为0，编码规范约束了Java字节码的具体实现。

if(boolean) 会判断boolean是否为0，0就跳过。if(boolean == true)会判断boolean是否为1，不为1就跳过。



Java虚拟机每调用一个Java方法便会创建一个栈帧。在解释器的解释栈帧中，主要包括两个主要组成部分，分别是局部变量区()和字节码的操作数栈。这里的局部变量是广义的，除了普遍意义下的局部变量之外，它还包含实例方法的“this 指针”以及方法所接收的参数。

在 Java 虚拟机规范中，局部变量区等价于一个数组，并且可以用正整数来索引。除了 long、double 值需要用两个数组单元来存储之外，其他基本类型以及引用类型的值均占用一个数组单元。当然，这种情况仅存在于局部变量，而并不会出现在存储于堆中的字段或者数组元素上。

如将int类型的值存储到boolean类型时，为了保证堆中的 boolean 值是合法的，HotSpot 在存储时显式地进行掩码操作，也就是说，只取最后一位的值存入 boolean 字段或数组中。Java 虚拟机的算数运算几乎全部依赖于操作数栈。也就是说，我们需要将堆中的 boolean、byte、char 以及 short 加载到操作数栈上，而后将栈上的值当成 int 类型来运算。对于无符号类型，加载伴随着零扩展(高位补0)。对于有符号类型，加载伴随着符号扩展(类型值填充低字节，正数最高位补0，负数补1，其余全部补0)。

## Java类如何加载

### 类加载器

JDK8及之前

启动类加载器：加载最为基础、最为重要的类，如存放在JRE的lib目录下的jar包中的类(以及由虚拟机参数-Xbootclasspath指定的类)。由C++编写，在java代码中表现为null。

扩展类加载器：加载相对次要、但又通用的类，比如存放在JRE的lib\ext目录下jar包中的类(以及由系统变量java.ext.dirs指定的类)。

应用类加载器：负责加载应用程序路径下的类(指由虚拟机参数-cp/-classpath、系统环境变量java.class.path指定的路径)。默认情况下，应用程序中包含的类便是由应用类加载器加载的。

JDK9及现在(引入模块化)

启动类加载器：加载少数几个关键模块，如java.base。

平台类加载器：其他模块。

程序类加载器

### 双亲委派机制

每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。

提供了隔离机制，在 Java 虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。提供了安全机制，最核心的类(如String)由启动类加载器加载，不可被相同类名的文件破坏。

### 类加载过程

#### 加载：

​	根据类的全限定名将该类的字节码加载到内存，生成代表该类的Class对象

#### 链接：

​	将创建好的Class对象合并到JVM，使之能够执行的过程。

##### 验证：

​	确保被加载类能够满足 Java 虚拟机的约束条件。

##### 准备：

​	为被加载类的静态字段分配内存，并设置默认值。被final修饰的static字段不会设置，因为在编译时就分配了。

##### 解析：

​	将类成员的符号引用变成直接引用。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。）

#### 初始化：

​	执行类的构造器方法init()的过程。这个方法不需要定义，是javac编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并来的。



类加载时不一定会触发初始化，只用主动使用类时，才会触发，如

1. 当虚拟机启动时，初始化用户指定的主类；
2. 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；
3. 当遇到调用静态方法的指令时，初始化该静态方法所在的类；
4. 当遇到访问静态字段的指令时，初始化该静态字段所在的类；
5. 子类的初始化会触发父类的初始化；
6. 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；
7. 使用反射 API 对某个类进行反射调用时，初始化这个类；
8. 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。

## Java如何执行方法调用

### Java方法调用

#### 重载

在 Java 程序里，如果同一个类中出现多个名字相同，但参数类型不同的方法，我们称之为重载。

重载的方法在编译过程中即可完成识别。具体到每一个方法调用，Java 编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法。选取的过程共分为三个阶段：

1. 在不考虑对基本类型自动装拆箱（auto-boxing，auto-unboxing），以及可变长参数的情况下选取重载方法；
2. 如果在第 1 个阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；
3. 如果在第 2 个阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法。

如果 Java 编译器在同一个阶段中找到了多个适配的方法，那么它会在其中选择一个最为贴切的，而决定贴切程度的一个关键就是形式参数类型的继承关系。

除了同一个类中的方法，重载也可以作用于这个类所继承而来的方法。也就是说，如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型不同，那么在子类中，这两个方法同样构成了重载。

#### 重写

如果子类具有一个和父类非私有方法的方法名，方法参数，方法返回值(可以不一致，但是必须是返回值的子类)一致的方法，如果是非静态的方法可以认为子类重写了父类方法，如果是静态方法，可以认为子类中的方法会隐藏掉父类的方法。

众所周知，Java 是一门面向对象的编程语言，它的一个重要特性便是多态。而方法重写，正是多态最重要的一种体现方式：它允许子类在继承父类部分功能的同时，拥有自己独特的行为。

### JVM方法调用

Java 虚拟机识别方法的关键在于类名、方法名以及方法描述符（method descriptor）。方法描述符是由方法的参数类型以及返回类型所构成。在同一个类中，如果同时出现多个名字相同且描述符也相同的方法，那么 Java 虚拟机会在类的验证阶段报错。

#### JVM 的静态绑定和动态绑定

Java 虚拟机与 Java 语言不同，它并不限制名字与参数类型相同，但返回类型不同的方法出现在同一个类中，对于调用这些方法的字节码来说，由于字节码所附带的方法描述符包含了返回类型，因此 Java 虚拟机能够准确地识别目标方法。

Java 虚拟机中关于方法重写的判定同样基于方法描述符。也就是说，如果子类定义了与父类中非私有、非静态方法同名的方法，那么只有当这两个方法的参数类型以及返回类型一致，Java 虚拟机才会判定为重写。

对于 Java 语言中重写而 Java 虚拟机中非重写的情况，编译器会通过生成桥接方法来实现 Java 中的重写语义。

在某些文章中，重载也被称为静态绑定（static binding），或者编译时多态（compile-time polymorphism）；而重写则被称为动态绑定（dynamic binding）。Java 虚拟机中的静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。

Java 字节码中与调用相关的指令共有五种：

1. invokestatic：用于调用静态方法。
2. invokespecial：用于调用私有实例方法、构造器，以及使用 super 关键字调用父类的实例方法或构造器，和所实现接口的默认方法。
3. invokevirtual：用于调用非私有实例方法。
4. invokeinterface：用于调用接口方法。
5. invokedynamic：用于调用动态方法。

#### 调用指令的符号引用

​	在编译过程中，我们并不知道目标方法的具体内存地址。因此，Java 编译器会暂时用符号引用来表示该目标方法。这一符号引用包括目标方法所在的类或接口的名字，以及目标方法的方法名和方法描述符。

​	符号引用存储在 class 文件的常量池之中。根据目标方法是否为接口方法，这些引用可分为接口符号引用和非接口符号引用。在执行使用了符号引用的字节码前，Java 虚拟机需要解析这些符号引用，并替换为实际引用。

​	对于非接口符号引用，假定该符号引用所指向的类为 C，则 Java 虚拟机会按照如下步骤进行查找。

1. 在 C 中查找符合名字及描述符的方法。
2. 如果没有找到，在 C 的父类中继续搜索，直至 Object 类。
3. 如果没有找到，在 C 所直接实现或间接实现的接口中搜索，这一步搜索得到的目标方法必须是非私有、非静态的。并且，如果目标方法在间接实现的接口中，则需满足 C 与该接口之间没有其他符合条件的目标方法。如果有多个符合条件的目标方法，则任意返回其中一个。

​	从这个解析算法可以看出，静态方法也可以通过子类来调用。此外，子类的静态方法会隐藏（注意与重写区分）父类中的同名、同描述符的静态方法。

​	对于接口符号引用，假定该符号引用所指向的接口为 I，则 Java 虚拟机会按照如下步骤进行查找。

1. 在 I 中查找符合名字及描述符的方法。
2. 如果没有找到，在 Object 类中的公有实例方法中搜索。
3. 如果没有找到，则在 I 的超接口中搜索。这一步的搜索结果的要求与非接口符号引用步骤 3 的要求一致。

​	**经过上述的解析步骤之后，符号引用会被解析成实际引用。对于可以静态绑定的方法调用而言，实际引用是一个指向方法的指针。对于需要动态绑定的方法调用而言，实际引用则是一个方法表的索引。**

#### 虚方法调用

​	Java方法调用中的invokevirtual和invokeinterface指令属于Java虚拟机的虚方法调用。在绝大数情况下(除非方法被声明为final)，Java虚拟机需要根据调用者的动态类型来确定虚方法调用的目标方法，此过程称为动态绑定。相对于静态绑定的方法调用来说，动态绑定的方法调用更耗时。

​	Java方法调用中的invokestatic和invokespecial指令属于静态绑定。如果虚方法调用指向一个标记为 final 的方法，那么 Java 虚拟机也可以静态绑定该虚方法调用的目标方法。

#### 方法表

​	Java虚拟机采用了一种空间换时间的策略来实现动态绑定。它为每个类生成一张方法表(类加载阶段中的准备阶阶段创建)，来快速定位目标方法。	

​	方法表本质上是一个数组，里面存放当前类和祖先类中非私有的实例方法，这些方法可能是已经实现的方法，也可能是抽象方法。方法表满足两个特性，一是子类方法表中包含父类方法表中的所有方法，二是子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同。

​	我们知道，方法调用指令中的符号引用会在执行之前解析成实际引用。对于静态绑定的方法调用而言，实际引用将指向具体的目标方法。对于动态绑定的方法调用而言，实际引用则是方法表的索引值（实际上并不仅是索引值）。

​	实际上，使用了方法表的动态绑定与静态绑定相比，仅仅多出几个内存解引用操作：访问栈上的调用者，读取调用者的动态类型，读取该类型的方法表，读取方法表中某个索引值所对应的目标方法。相对于创建并初始化 Java 栈帧来说，这几个内存解引用操作的开销简直可以忽略不计。

​	方法表的动态绑定存在于解释执行中和即时编译的超多态情况。

#### 内联缓存

​	内联缓存是一种加快动态绑定的优化技术。它能够缓存调用者的动态类型，以及该类型所对应的目标方法，以后执行时，如果碰到已缓存的类型，内联缓存便会直接调用该类型所对应的目标方法。如果没有碰到缓存类型，则会退化为方法表的动态绑定。

​	在针对多态的优化手段中，我们通常会提及以下三个术语。

 	1. 单态（monomorphic）指的是仅有一种状态的情况。
 	2. 多态（polymorphic）指的是有限数量种状态的情况。二态（bimorphic）是多态的其中一种。
 	3. 超多态（megamorphic）指的是更多种状态的情况。通常我们用一个具体数值来区分多态和超多态。在这个数值之下，我们称之为多态。否则，我们称之为超多态。

​	单态内联缓存，顾名思义，便是只缓存了一种动态类型以及它所对应的目标方法。它的实现非常简单：比较所缓存的动态类型，如果命中，则直接调用对应的目标方法。

​	多态内联缓存则缓存了多个动态类型及其目标方法。它需要逐个将所缓存的动态类型与当前动态类型进行比较，如果命中，则调用对应的目标方法。

​	超多态内联缓存则放弃了优化的机会，它将直接访问方法表，来动态绑定目标方法。

为了节省内存空间，Java 虚拟机只采用单态内联缓存。当内联缓存没有命中时，Java虚拟机则劣化为超多态状态，将直接访问方法表，来动态绑定目标方法。

​	虽然内联缓存附带内联二字，但是它并没有内联目标方法。这里需要明确的是，任何方法调用除非被内联，否则都会有固定开销。这些开销来源于保存程序在该方法中的执行位置，以及新建、压入和弹出新方法所使用的栈帧。对于极其简单的方法而言，比如说 getter/setter，这部分固定开销占据的 CPU 时间甚至超过了方法本身。此外，在即时编译中，方法内联不仅仅能够消除方法调用的固定开销，而且还增加了进一步优化的可能性。



## Java如何处理异常

异常处理的两大组成元素是抛出异常和捕获异常。这两大要素共同实现程序控制流的非正常转移。

### 抛出异常

​	抛出异常可分为显式和隐式。显式抛出是指应用程序使用 throw 关键字手动将异常实例抛出。隐式抛出是指Java虚拟机在执行过程中，碰到无法继续执行的异常状态时自动抛出。

### 捕获异常

​	捕获异常则涉及了如下三种代码块：

	1. try 代码块：用来标记需要进行异常监控的代码。
	1. catch 代码块：跟在 try 代码块之后，用来捕获在 try 代码块中触发的某种指定类型的异常。除了声明所捕获异常的类型之外，catch 代码块还定义了针对该异常类型的异常处理器。在 Java 中，try 代码块后面可以跟着多个 catch 代码块，来捕获不同类型的异常。Java 虚拟机会从上至下匹配异常处理器。因此，前面的 catch 代码块所捕获的异常类型不能覆盖后边的，否则编译器会报错。
	1. finally代码块：跟在try代码块和catch代码块后，用来声明一段必须执行的代码。设计的初衷是为了避免跳过某些关键的清理代码，如关闭一些打开的系统资源。

​	在程序正常执行后，会调用finally代码块。否则会在catch 代码块捕获并处理过异常后调用。如果catch没有捕获到异常，则直接执行finally代码块然后继续抛出该异常。如果catch 代码块也抛出异常，finally代码块运行后会继续抛出该异常。最糟糕的情况是finally代码块也遇到异常，此时中断执行，并往外抛出异常。

### 异常的基本概念

​	在Java规范中，所有异常都是Throwable类或者其子类的实例。Throwable由两大直接子类。第一个是Error，涵盖程序不该捕获的异常，当程序触发Error时，它的执行状态已经无法恢复，需要中止线程甚至中止虚拟机。第二个是Exception，涵盖可能需要捕获并且处理的异常。Exception有一个特殊的子类RuntimeException，用来表示程序虽然无法继续执行，但是还能抢救一下。

​	Error和RuntimeException属于非检查异常(unchecked exception)，其他异常属于检查异常(checked exception)。检查异常需要在程序中显式的捕获，或者在方法中标记throws关键字，抛到调用者去处理。

​	异常实例的构造十分昂贵。由于构造异常实例时，Java虚拟机需要生成该异常的栈轨迹(stack trace)。该操作会一一访问当前线程的Java栈帧，并记录下各种调式信息，包括栈帧指向的方法名、类名、以及触发的位置。

### Java虚拟机捕获异常

​	在编译生成的字节码中，每个方法都有一个异常表。表中的每条记录都代表一个异常处理器，记录中包括from指针、to指针、target指针和捕获的异常类型。这些指针的值时字节码索引，用以定位字节码。

​	其中form指针和to指针标示了该异常处理器监控的范围，如try代码块覆盖的范围。target指针指向异常处理器的起始位置，如catch代码块的起始位置。

​	当程序触发异常时，Java 虚拟机会从上至下遍历异常表中的所有条目。当触发异常的字节码的索引值在某个异常表条目的监控范围内，Java 虚拟机会判断所抛出的异常和该条目想要捕获的异常是否匹配。

​	finally 代码块的编译比较复杂。当前版本 Java 编译器的做法，是复制 finally 代码块的内容，分别放在 try-catch 代码块所有正常执行路径以及异常执行路径的出口中。



如果 catch 代码块捕获了异常，并且触发了另一个异常，那么 finally 捕获并且重抛的异常是哪个呢？答案是后者。也就是说原本的异常便会被忽略掉，这对于代码调试来说十分不利。

### Java7的Suppressed异常以及语法糖

​	Java7引入Suppressed异常来解决原本的异常被忽略掉的问题。这个特性允许将一个异常依附于另一个异常上，因此，抛出的异常可以附带多个异常信息。然而Java层面的finally代码块缺少指向所捕获的异常的引用(catch代码块可以声明异常，finally代码块不可以)，所以这个特性使用起来非常繁琐。

​	为此，Java7专门构建了一个try-with-resources 的语法糖，在字节码层面自动使用Suppressed异常。当然，该语法糖的主要目的并不是使用 Suppressed 异常，而是精简资源打开关闭的用法。

​	try-with-resources 语法糖允许在 try 关键字后声明并实例化实现了 AutoCloseable 接口的类，编译器将自动添加对应的 close() 操作。与手工代码调用close()操作相比，try-with-resources 还会使用 Suppressed 异常的功能，来避免原异常“被消失”。

​	除了 try-with-resources 语法糖之外，Java 7 还支持在同一 catch 代码块中捕获多种异常。实际实现非常简单，生成多个异常表条目即可。

## Java处理反射

### 反射 	

​	Reflection(反射) 是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序对自身进行检查。通过反射，我们可以在运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。

#### 功能

Java 反射主要提供以下功能：

- 在运行时判断任意一个对象所属的类；
- 在运行时构造任意一个类的对象；
- 在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；
- 在运行时调用任意一个对象的方法

#### 运用

​	Java反射的基本运用:

	+ 获得 Class 对象。有三种方式，Class.forName("类名") 、对象.getClass() 、int.class。
	+ 判断是否为某个类的实例。instanceof关键字或者Class.对象的isInstance()方法。
	+ 创建实例。使用Class对象的newInstance()方法来创建Class对象对应类的实例。或者先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。
	+ 获取方法。`getDeclaredMethods` 方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。`getMethods` 方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。
	+ 获取类的成员变量（字段）信息。`getFiled`：访问公有的成员变量。`getDeclaredField`：所有已声明的成员变量，但不能得到其父类的成员变量
	+ 调用方法。Method.invoke
	+ 利用反射创建数组。Array.newInstance(Class<?>,int)

### 反射调用实现

​	方法的反射调用通过Method.invoke实现，方法执行时会委派给MethodAccessor执行。MethodAccessor 是一个接口，它有两个已有的具体实现：一个通过本地方法来实现反射调用，另一个则使用了委派模式。每个 Method 实例的第一次反射调用都会生成一个委派实现，它所委派的具体实现便是一个本地实现(C++调用)。

~~~java
    public Object invoke(Object obj, Object... args)
        throws IllegalAccessException, IllegalArgumentException,
           InvocationTargetException
    {
        if (!override) {
            Class<?> caller = Reflection.getCallerClass();
            checkAccess(caller, clazz,
                        Modifier.isStatic(modifiers) ? null : obj.getClass(),
                        modifiers);
        }
        MethodAccessor ma = methodAccessor;             // read volatile
        if (ma == null) {
            ma = acquireMethodAccessor();
        }
        return ma.invoke(obj, args);
    }
~~~

​	反射调用先是调用了 Method.invoke，然后进入委派实现（DelegatingMethodAccessorImpl），再然后进入本地实现（NativeMethodAccessorImpl），最后到达目标方法。

​	Java 的反射调用机制还设立了另一种动态生成字节码的实现（下称动态实现），直接使用 invoke 指令来调用目标方法。之所以采用委派实现，便是为了能够在本地实现以及动态实现中切换。

~~~java
// 动态实现的伪代码，这里只列举了关键的调用逻辑，其实它还包括调用者检测、参数检测的字节码。
// 生成直接调用方法的Java代码，和平时写的方法调用一样
package jdk.internal.reflect;
public class GeneratedMethodAccessor1 extends ... { 
    @Overrides 
    public Object invoke(Object obj, Object[] args) throws ... { 
    	Test.target((int) args[0]); 
        return null; 
    }
}
~~~

​	动态实现和本地实现相比，其运行效率要快上 20 倍  。这是因为动态实现无需经过 Java 到 C++ 再到 Java 的切换，但由于生成字节码十分耗时，仅调用一次的话，反而是本地实现要快上 3 到 4 倍 。

​	考虑到许多反射调用仅会执行一次，Java 虚拟机设置了一个阈值 15（可以通过 -Dsun.reflect.inflationThreshold= 来调整），当某个反射调用的调用次数在 15 之下时，采用本地实现；当达到 15 时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现，这个过程我们称之为 Inflation。反射调用的 Inflation 机制是可以通过参数（-Dsun.reflect.noInflation=true）来关闭的。这样一来，在反射调用一开始便会直接生成动态实现，而不会使用委派实现或者本地实现。

### 反射调用开销

​	反射调用涉及到Class.forName，Class.getMethod 以及 Method.invoke 三个操作。其中，Class.forName 会调用本地方法，Class.getMethod 则会遍历该类的公有方法。如果没有匹配到，它还将遍历父类的公有方法。以 getMethod 为代表的查找方法操作，会返回查找得到结果的一份拷贝，将带来额外的堆空间消耗。

​	方法的反射调用会带来不少性能开销，原因主要有三个：变长参数方法导致的 Object 数组(Method.invoke是个变长参数)	，基本类型的自动装箱、拆箱，还有最重要的方法内联。

## JVM实现invokedynamic

​	在 Java 中，方法调用会被编译为 invokestatic，invokespecial，invokevirtual 以及 invokeinterface 四种指令。这些指令与包含目标方法类名、方法名以及方法描述符的符号引用捆绑。在实际运行之前，Java 虚拟机将根据这个符号引用链接到具体的目标方法。在这四种调用指令中，Java 虚拟机明确要求方法调用需要提供目标方法的类名。

​	Java 7 引入了一条新的指令 invokedynamic。该指令的调用机制抽象出调用点这一个概念，并允许应用程序将调用点链接至任意符合条件的方法上。 invokedynamic的实现基于方法句柄（MethodHandle）。

​	方法句柄是一个强类型的、能够被直接执行的引用。它仅关心所指向方法的参数类型以及返回类型，而不关心方法所在的类以及方法名。方法句柄的权限检查发生在创建过程中，相较于反射调用节省了调用时反复权限检查的开销。

​	方法句柄可以通过 invokeExact 以及 invoke 来调用。其中，invokeExact 要求传入的参数和所指向方法的描述符严格匹配。方法句柄还支持增删改参数的操作，这些操作是通过生成另一个充当适配器的方法句柄来实现的。

​	方法句柄可以通过 invokeExact 以及 invoke 来调用。其中，invokeExact 要求传入的参数和所指向方法的描述符严格匹配。方法句柄还支持增删改参数的操作，这些操作是通过生成另一个充当适配器的方法句柄来实现的。

​	invokedymaic 指令抽象出调用点的概念，并且将调用该调用点所链接的方法句柄。在第一次执行 invokedynamic 指令时，Java 虚拟机将执行它所对应的启动方法，生成并且绑定一个调用点。之后如果再次执行该指令，Java 虚拟机则直接调用已经绑定了的调用点所链接的方法。

​	Lambda 表达式到函数式接口的转换是通过 invokedynamic 指令来实现的。该 invokedynamic 指令对应的启动方法将通过 ASM 生成一个适配器类。对于没有捕获其他变量的 Lambda 表达式，该 invokedynamic 指令始终返回同一个适配器类的实例。对于捕获了其他变量的 Lambda 表达式，每次执行 invokedynamic 指令将新建一个适配器类实例。

​	不管是捕获型的还是未捕获型的 Lambda 表达式，它们的性能上限皆可以达到直接调用的性能。其中，捕获型 Lambda 表达式借助了即时编译器中的逃逸分析，来避免实际的新建适配器类实例的操作。

## Java对象内存布局

### 对象结构

#### 对象头(Object Header)

##### 对象标记(markOop)

​	存储对象本身运行时的数据，如哈希码、GC标记(分代年龄？)、锁信息、线程关联信息等。这部分数据在64位JVM占8字节(64bit/8byte)。

##### 类元信息(klassOop)

​	存储指向对象本身的类元数据(即Klass)的首地址。这部分数据在64位JVM中，如果开启压缩指针占4字节，不开启占8字节。

#### 数组长度

​	这部分只有是数组对象才有，如果是非数组对象，就没这部分了，这部分占4字节（32bit）。

#### 实例数据(Instance Data)

​	分为基础数据类型和引用类型。基础数据类型按照类型的大小计算，引用类型在64位JVM中，如果开启压缩指针占4字节，不开启占8字节。

#### 对齐填充(Padding)

​	默认情况下，Java 虚拟机堆中对象的起始地址需要对齐至 8(对应虚拟机选项 -XX:ObjectAlignmentInBytes，默认值为 8) 的倍数(内存对齐)。如果一个对象用不到 8N 个字节，那么空白的那部分空间就浪费掉了。这些浪费掉的空间我们称之为对象间的填充。-XX:ObjectAlignmentInBytes设置的越大越浪费，比如对于一个17字节的对象，如果ObjectAlignmentInBytes=8，则需要填充7字节。如果ObjectAlignmentInBytes=16，则需要填充15字节。

​	内存对齐和压缩指针有一定的关系。压缩指针的原理是寻址单位不同。未开启压缩指针前，指针保存对象的真实内存地址,开启后保存对象的映射地址。打个比方，路上停着的全是房车，而且每辆房车恰好占据两个停车位。现在，我们按照顺序给它们编号。也就是说，停在 0 号和 1 号停车位上的叫 0 号车，停在 2 号和 3 号停车位上的叫 1 号车，依次类推。原本的内存寻址用的是车位号。比如说我有一个值为 6 的指针，代表第 6 个车位，那么沿着这个指针可以找到 3 号车。现在我们规定指针里存的值是车号，比如 3 指代 3 号车。当需要查找 3 号车时，我便可以将该指针的值乘以 2，再沿着 6 号车位找到 3 号车。

​	默认情况下，JVM以8((对应虚拟机选项 -XX:ObjectAlignmentInBytes，默认值为 8))字节对齐，所以映射地址可以映射出真实内存地址的8倍。压缩指针占4个字节(32bit)，CPU寻址的单位为byte，映射的最大真实内存地址为 2 ^ 32 * 8 (byte)=  32G。所以对于64位JVM，不超过32G内存时自动开启压缩指针。

​	当然，就算是关闭了压缩指针，Java 虚拟机还是会进行内存对齐。此外，内存对齐不仅存在于对象与对象之间，也存在于对象中的字段之间。比如说，Java 虚拟机要求 long 字段、double 字段，以及非压缩指针状态下的引用字段地址为 8 的倍数。

​	字段内存对齐的其中一个原因，是让字段只出现在同一 CPU 的缓存行中。如果字段不是对齐的，那么就有可能出现跨缓存行的字段。也就是说，该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。这两种情况对程序的执行效率而言都是不利的。

#### 字段重排序

​	**字段重排列，顾名思义，就是 Java 虚拟机重新分配字段的先后顺序，以达到内存对齐的目的。**Java 虚拟机中有三种排列方法（对应 Java 虚拟机选项 -XX:FieldsAllocationStyle，默认值为 1），但都会遵循如下两个规则。

​	其一，**如果一个字段占据 C 个字节，那么该字段的偏移量需要对齐至 NC。这里偏移量指的是字段地址与对象的起始地址差值。**以 long 类为例，它仅有一个 long 类型的实例字段。在使用了压缩指针的 64 位虚拟机中，尽管对象头的大小为 12 个字节，该 long 类型字段的偏移量也只能是 16，而中间空着的 4 个字节便会被浪费掉。

​	其二，**子类所继承字段的偏移量，需要与父类对应字段的偏移量保持一致。在具体实现中，Java 虚拟机还会对齐子类字段的起始位置。**对于使用了压缩指针的 64 位虚拟机，子类第一个字段需要对齐至 4N；而对于关闭了压缩指针的 64 位虚拟机，子类第一个字段则需要对齐至 8N。

~~~java
class A {
  long l;
  int i；
}

class B extends A {
  long l;
  int i;
}
~~~

~~~java
# 启用压缩指针时，B类的字段分布
B object internals:
 OFFSET  SIZE   TYPE DESCRIPTION
      0     4        (object header)
      4     4        (object header)
      8     4        (object header)
     12     4    int A.i                                       0
     16     8   long A.l                                       0
     24     8   long B.l                                       0
     32     4    int B.i                                       0
     36     4        (loss due to the next object alignment)
~~~

​	当启用压缩指针时，可以看到 Java 虚拟机将 A 类的 int 字段放置于 long 字段之前，以填充因为 long 字段对齐造成的 4 字节缺口。由于对象整体大小需要对齐至 8N，因此对象的最后会有 4 字节的空白填充。

~~~
# 关闭压缩指针时，B类的字段分布
B object internals:
 OFFSET  SIZE   TYPE DESCRIPTION
      0     4        (object header)
      4     4        (object header)
      8     4        (object header)
     12     4        (object header)
     16     8   long A.l
     24     4    int A.i
     28     4        (alignment/padding gap)                  
     32     8   long B.l
     40     4    int B.i
     44     4        (loss due to the next object alignment)
~~~

​	Java 8 还引入了一个新的注释 @Contended，用来解决对象字段之间的虚共享（false sharing）问题。这个注释也会影响到字段的排列。Java 虚拟机会让不同的 @Contended 字段处于独立的缓存行中，因此你会看到大量的空间被浪费掉。

## 垃圾回收(Garbage Collection)

​	JVM中内存是自动管理的，由垃圾回收器将已经分配出去的，但却不再使用的内存回收回来，以便能够再次分配。大致流程为先辨别(标记)出不使用的对象，然后进行回收。

### 标记方法

#### 引用计数法(reference counting)

​	为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为 0，则说明该对象已经死亡，便可以被回收了。

​	除了需要额外的空间来存储计数器，以及繁琐的更新操作，引用计数法还有一个重大的漏洞，那便是无法处理循环引用对象。假设对象 a 与 b 相互引用，除此之外没有其他引用指向 a 或者 b。在这种情况下，a 和 b 实际上已经死了，但由于它们的引用计数器皆不为 0，在引用计数法的心中，这两个对象还活着。因此，这些循环引用对象所占据的空间将不可回收，从而造成了内存泄露。

#### 根可达算法

​	这个算法的实质在于将一系列 GC Roots 作为初始的存活对象合集（live set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。

​	GC Roots可以暂时理解为由堆外指向堆内的引用，一般分为如下几种：

 	1. 已加载类的静态变量；
 	2. 常量引用的对象；
 	3. Java 方法栈桢中的局部变量；
 	4. 本地方法占中引用的对象；

​	虽然可达性分析的算法本身很简明，但是在实践中还是有不少其他问题需要解决的。比如说，在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成误报（将引用设置为 null）或者漏报（将引用设置为未被访问过的对象）。误报对于JVM来说，最多损失了部分垃圾回收的机会。但是漏报比较麻烦，如果垃圾回收器回收事实上仍被引用的对象内存。一旦从原引用访问已经被回收了的对象，则很有可能会直接导致 Java 虚拟机崩溃。

##### Stop-the-world 以及安全点

​	怎么解决这个问题呢？在 Java 虚拟机里，传统的垃圾回收算法采用的是一种简单粗暴的方式，那便是 Stop-the-world，停止其他非垃圾回收线程的工作，直到完成垃圾回收。这也就造成了垃圾回收所谓的暂停时间（GC pause）。

​	**Java 虚拟机中的 Stop-the-world 是通过安全点（safepoint）机制来实现的。当 Java 虚拟机收到 Stop-the-world 请求，它便会等待所有的线程都到达安全点，才允许请求 Stop-the-world 的线程进行独占的工作。**安全点的初始目的并不是让其他线程停下，而是找到一个稳定的执行状态。在这个执行状态下，Java 虚拟机的堆栈不会发生变化。这么一来，垃圾回收器便能够“安全”地执行可达性分析。

​	举个例子，当 Java 程序通过 JNI 执行本地代码时，如果这段代码不访问 Java 对象、调用 Java 方法或者返回至原 Java 方法，那么 Java 虚拟机的堆栈不会发生改变，也就代表着这段本地代码可以作为同一个安全点。只要不离开这个安全点，Java 虚拟机便能够在垃圾回收的同时，继续运行这段本地代码。

​	由于本地代码需要通过 JNI 的 API 来完成上述三个操作，因此 Java 虚拟机仅需在 API 的入口处进行安全点检测（safepoint poll），测试是否有其他线程请求停留在安全点里，便可以在必要的时候挂起当前线程。

​	除了执行 JNI 本地代码外，Java 线程还有其他几种状态：解释执行字节码、执行即时编译器生成的机器码和线程阻塞。阻塞的线程由于处于 Java 虚拟机线程调度器的掌控之下，因此属于安全点。其他几种状态则是运行状态，**需要虚拟机保证在可预见的时间内进入安全点。否则，垃圾回收线程可能长期处于等待所有线程进入安全点的状态，从而变相地提高了垃圾回收的暂停时间。**

​	对于解释执行来说，字节码与字节码之间皆可作为安全点。Java 虚拟机采取的做法是，当有安全点请求时，执行一条字节码便进行一次安全点检测。

​	执行即时编译器生成的机器码则比较复杂。由于这些代码直接运行在底层硬件之上，不受 Java 虚拟机掌控，因此在生成机器码时，即时编译器需要插入安全点检测，以避免机器码长时间没有安全点检测的情况。HotSpot 虚拟机的做法便是在生成代码的方法出口以及非计数循环的循环回边（back-edge）处插入安全点检测。

​	那么为什么不在每一条机器码或者每一个机器码基本块处插入安全点检测呢？原因主要有两个。

​	第一，安全点检测本身也有一定的开销。不过 HotSpot 虚拟机已经将机器码中安全点检测简化为一个内存访问操作。在有安全点请求的情况下，Java 虚拟机会将安全点检测访问的内存所在的页设置为不可读，并且定义一个 segfault 处理器，来截获因访问该不可读内存而触发 segfault 的线程，并将它们挂起。

​	第二，即时编译器生成的机器码打乱了原本栈桢上的对象分布状况。在进入安全点时，机器码还需提供一些额外的信息，来表明哪些寄存器，或者当前栈帧上的哪些内存空间存放着指向对象的引用，以便垃圾回收器能够枚举 GC Roots。

### 整理方法

#### 清除(sweep)

​	将死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。

​	清除这种回收方式的原理及其简单，但是有两个缺点。一是会**造成内存碎片**。由于 Java 虚拟机的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。另一个则是**分配效率较低**。如果是一块连续的内存空间，那么我们可以通过指针加法（pointer bumping）来做分配。而对于空闲列表，Java 虚拟机则需要逐个访问列表中的项，来查找能够放入新建对象的空闲内存。

#### 压缩	

​	将存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。

#### 复制

​	即把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到 to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。复制这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。

### 分代回收

​	根据假设，大部分的 Java 对象只存活一小段时间，而存活下来的小部分 Java 对象则会存活很长一段时间。提出了JVM的分代回收思想，新生代和老年代，可以对不同代使用不同的回收算法。

​	对于新生代，我们猜测大部分的 Java 对象只存活一小段时间，那么便可以频繁地采用耗时较短的垃圾回收算法，让大部分的垃圾都能够在新生代被回收掉。对于老年代，我们猜测大部分的垃圾已经在新生代中被回收了，而在老年代中的对象有大概率会继续存活。当真正触发针对老年代的回收时，则代表这个假设出错了，或者堆的空间已经耗尽了。这时候，Java 虚拟机往往需要做一次全堆扫描，耗时也将不计成本。

### JVM堆划分

​	前面提到，Java 虚拟机将堆划分为新生代和老年代。其中，新生代又被划分为 Eden 区，以及两个大小相同的 Survivor 区。默认情况下，Java 虚拟机采取的是一种动态分配的策略（对应 Java 虚拟机参数 -XX:+UsePSAdaptiveSurvivorSizePolicy），根据生成对象的速率，以及 Survivor 区的使用情况动态调整 Eden 区和 Survivor 区的比例。当然，你也可以通过参数 -XX:SurvivorRatio 来固定这个比例。但是需要注意的是，其中一个 Survivor 区会一直为空，因此比例越低浪费的堆空间将越高。

​	通常来说，当我们调用 new 指令时，它会在 Eden 区中划出一块作为存储对象的内存。由于堆空间是线程共享的，因此直接在这里边划空间是需要进行同步的。否则，将有可能出现两个对象共用一段内存的事故。为了防止该情况，JVM采用TLAB（Thread Local Allocation Buffer，对应虚拟机参数 -XX:+UseTLAB，默认开启）预先给线程分配一段连续的内存，作为线程私有的 TLAB。这个操作需要加锁，线程需要维护两个指针（实际上可能更多，但重要也就两个），一个指向 TLAB 中空余内存的起始位置，一个则指向 TLAB 末尾。接下来的 new 指令，便可以直接通过指针加法（bump the pointer）来实现，即把指向空余内存位置的指针加上所请求的字节数。如果加法后空余内存指针的值仍小于或等于指向末尾的指针，则代表分配成功。否则，TLAB 已经没有足够的空间来满足本次新建操作。这个时候，便需要当前线程重新申请新的 TLAB。

​	当 Eden 区的空间耗尽了怎么办？这个时候 Java 虚拟机便会触发一次 Minor GC，来收集新生代的垃圾。存活下来的对象，则会被送到 Survivor 区。前面提到，新生代共有两个 Survivor 区，我们分别用 from 和 to 来指代。其中 to 指向的 Survivior 区是空的。当发生 Minor GC 时，Eden 区和 from 指向的 Survivor 区中的存活对象会被复制到 to 指向的 Survivor 区中，然后交换 from 和 to 指针，以保证下一次 Minor GC 时，to 指向的 Survivor 区还是空的。

​	Java 虚拟机会记录 Survivor 区中的对象一共被来回复制了几次。如果一个对象被复制的次数为 15（对应虚拟机参数 -XX:+MaxTenuringThreshold，对象头中使用4bit来存，因此最大15），那么该对象将被晋升（promote）至老年代。另外，如果单个 Survivor 区已经被占用了 50%（对应虚拟机参数 -XX:TargetSurvivorRatio），那么较高复制次数的对象也会被晋升至老年代。

​	总而言之，当发生 Minor GC 时，我们应用了标记 - 复制算法，将 Survivor 区中的老存活对象晋升到老年代，然后将剩下的存活对象和 Eden 区的存活对象复制到另一个 Survivor 区中。理想情况下，Eden 区中的对象基本都死亡了，那么需要复制的数据将非常少，因此采用这种标记 - 复制算法的效果极好。Minor GC 的另外一个好处是不用对整个堆进行垃圾回收。但是，它却有一个问题，那就是老年代的对象可能引用新生代的对象。也就是说，在标记存活对象的时候，我们需要扫描老年代中的对象。如果该对象拥有对新生代对象的引用，那么这个引用也会被作为 GC Roots。

​	这样一来，岂不是又做了一次全堆扫描呢？

### 卡表

​	HotSpot 给出的解决方案是一项叫做卡表（Card Table）的技术。该技术将整个堆划分为一个个大小为 512 字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表对应的卡是否可能存有指向新生代对象的引用。如果可能存在，那么我们就认为这张卡是脏的。

​	在进行 Minor GC 的时候，我们便可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到 Minor GC 的 GC Roots 里。当完成所有脏卡的扫描之后，Java 虚拟机便会将所有脏卡的标识位清零。由于 Minor GC 伴随着存活对象的复制，而复制需要更新指向该对象的引用。因此，在更新引用的同时，我们又会设置引用所在的卡的标识位。这个时候，我们可以确保脏卡中必定包含指向新生代对象的引用。在 Minor GC 之前，我们并不能确保脏卡中包含指向新生代对象的引用。其原因和如何设置卡的标识位有关。首先，如果想要保证每个可能有指向新生代对象引用的卡都被标记为脏卡，那么 Java 虚拟机需要截获每个引用型实例变量的写操作，并作出对应的写标识位操作。这个操作在解释执行器中比较容易实现。但是在即时编译器生成的机器码中，则需要插入额外的逻辑。这也就是所谓的写屏障（write barrier，注意不要和 volatile 字段的写屏障混淆）。写屏障需要尽可能地保持简洁。这是因为我们并不希望在每条引用型实例变量的写指令后跟着一大串注入的指令。因此，写屏障并不会判断更新后的引用是否指向新生代中的对象，而是宁可错杀，不可放过，一律当成可能指向新生代对象的引用。

​	虽然写屏障不可避免地带来一些开销，但是它能够加大 Minor GC 的吞吐率（ 应用运行时间 /(应用运行时间 + 垃圾回收时间) ）。总的来说还是值得的。不过，在高并发环境下，写屏障又带来了虚共享（false sharing）问题。

​	在介绍对象内存布局中我曾提到虚共享问题，讲的是几个 volatile 字段出现在同一缓存行里造成的虚共享。这里的虚共享则是卡表中不同卡的标识位之间的虚共享问题。在 HotSpot 中，卡表是通过 byte 数组来实现的。对于一个 64 字节的缓存行来说，如果用它来加载部分卡表，那么它将对应 64 张卡，也就是 32KB 的内存。如果同时有两个 Java 线程，在这 32KB 内存中进行引用更新操作，那么也将造成存储卡表的同一部分的缓存行的写回、无效化或者同步操作，因而间接影响程序性能。为此，HotSpot 引入了一个新的参数 -XX:+UseCondCardMark，来尽量减少写卡表的操作。

### 垃圾回收器

## JAVA内存模型

​	由于计算机处理器和存储设备的运算速度有几个数量级的差距，所以现代计算机系统不得不加入一层高速缓存来作为内存和处理器之间的缓存。基于高速缓存的存储交互很好的解决了处理器和内存速度的矛盾，但引入了缓存一致性(Cache Coherence)问题，即多个高速缓存将同一个数据写入到主内存中，以哪个为准。为了解决一致性问题，又引入了一些协议，如MESI等。

​	JVM的即时编译器为了提高执行速度，可能会对执行进行重排序，以此来提高执行速度。但是无法对有数据以来的指令进行重排序，而且要遵守“线程内表现为串行的语义”(Within-Thread As-If-Serial Semantics)，即代码在单线程中重排序的执行结果和未重排序的执行结果一致。但因为执行重排序以及工作内存(高速缓存)与主内存同步延迟的情况导致会出现并发安全(执行结果不唯一(每次执行可能有不同的结果)，且与预期不符合)问题。

​	Java内存模型(Java Memory Model,JMM)来屏蔽各种硬件的和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。可以解决相同的代码在不同的平台并发行为不一致的情况。

​	JMM主要的目的时定义程序中各种变量(实例字段，静态字段和构成数组对象的元素，不包括线程私有的变量(如局部变量，方法参数))的访问规则，即关注在虚拟机中把变量值存储到内存中和从内存中取出变量值这样的底层细节。JMM规定所有的变量都存储在主内存中，每个线程还有自己的工作内存(保存主内存变量的副本，不是全部复制，只复制需要的字段)。线程对变量的操作要在工作内存中进行，不能直接操作主内存。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

### 内存间交互操作

​	关于主内存和工作内存之间具体的交互协议，即如何把一个变量从主内存复制到工作内存，如何把工作内存的变量同步回主内存。JMM定义了8个原子性操作来完成。

#### 原子性操作

+ lock：作用于主内存变量，将一个变量标记为线程独占。
+ unlock：作用于主内存变量，将处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
+ read：作用于主内存变量，将变量的值从主内存拷贝到工作内存，以便随后的load操作使用。
+ load：作用于工作内存变量，将read操作拷贝的变量的值放到工作内存的变量副本中。
+ use：作用于工作内存变量，将工作内存的变量的值传递给执行引擎，每当JVM遇到一个需要使用变量的值的字节码指令时需要执行这个操作。
+ assign：作用于工作内存变量，将从执行引擎接收的值赋给工作内存中的变量，每当JVM遇到一个需要给变量赋值的字节码指令时需要执行这个操作。
+ store：作用于工作内存变量，将变量的值从工作内存拷贝到主内存，以便随后的write操作使用。
+ write：作用于主内存变量，将store操作拷贝的变量的值同步回主内存变量中。

read和load操作，还有store和write操作必须按顺序执行，但不要求连续执行。

#### 原子性操作规则

JMM还规定了8中基本操作时必须满足如下规则：

+ 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写操作但主内存不接受的情况。
+ 不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了必须把变化同步会主内存。
+ 不允许一个线程无原因地(没发生过任何assign操作)把变量从工作内存同步回主内存。
+ 一个新的变量只能在主内存中"产生"，不允许在工作内存中直接使用一个未被初始化(load或assign)的变量，换句话说就是对一个变量实施use、store操作之前，必须执行assign和load操作。
+ 一个变量在同一时刻只允许一个线程对其进行lock操作，但lock操作可以被同一个线程重复执行多次，多次执行lock操作后，必须执行相同次数的unlock操作才能解锁。
+ 如果对一个变量执行lock操作，将会清空工作内存中该变量的值，在执行引擎使用这个变量前，需要重新执行load或assign以初始化变量的值。
+ 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。
+ 对一个变量执行unlock操作之前，必须先把该变量同步会主内存中(执行store、write操作)。

为了准确地描述出Java程序那些内存访问操作在并发下是安全的。

#### volatile特殊规则

​	被volatile修饰的变量具有可见性和有序性(禁止指令重排序)，但不具有原子性。

​	可见性保证：因为volatile变量每次使用时都会进行read、load操作从主内存读取变量值，每次修改时都会进行store、write操作将变量的值同步回主内存中，因此volatile的值对所有线程是立刻可见的。

​	有序性保证（禁止指令重排序）：通过对比volatile变量和非volatile变量赋值的字节码可以发现，volatile变量赋值后会多执行一个"lock addl $0x0,(%esp)"操作，这个操作相当于一个内存屏障保证(Memory Barrier/Memory Fence，指令重排序时不能把后面的指令重排序到内存屏障之前的位置)。"lock addl $0x0,(%esp)"(把ESP寄存器的值加0)是一个空操作，不适用空操作专用指令nop是因为规定lock前缀不允许配合nop执行。lock前缀会将本处理器的缓存写入到内存中，相当于进行了store和write操作，可以让volatile变量的修改对其他处理器立刻可见。指令重排序无法对有依赖关系的数据进行排序，"lock addl $0x0,(%esp)"刷新缓存时，代表之前有数据依赖的操作都已生效，这样就筑起了“内存屏障”。

JMM对volatile变量定义的特殊规则

+ 要求use、load、read操作必须连续且一起出现。每次都能从主内存中获取最新的变量值。
+ 要求assign、store、write操作必须连续且一起出现。每次修改都能立刻同步会主内存。
+ 同一线程中，先对volatile变量A进行了use或assign操作，后对volatile变量B进行了use或assign操作，那么变量A的read或write操作先于变量B的read或write操作。规定volatile修饰的变量不会被指令重排序优化，从而保证代码的执行顺序和程序的顺序相同。

#### 针对long和double变量的特殊规则

​	JMM允许JVM对未被volatile修饰的64位数据读写分为两次32位的操作来进行。

#### 原子性、可见性和有序性

​	JMM围绕着在并发过程中如何处理原子性、可见性和有序性这三个特征建立的。下面罗列了哪些操作实现了这三个特性

​	原子性：JMM直接保证的原子性操作包括read、load、use、assign、store、write这六个。如果需要更大范围的原子性保证可以使用lock和unlock，JVM未暴露这两个操作，但提供了更高层次的字节码指令monitorenter和moniterexit来隐式地操作。这两个字节码指令对应着synchronized关键字。

​	可见性：volatile变量由每次读主内存的值，每次将修改写回主内存保证。synchronized由 对一个变量执行unlock操作之前，必须先把该变量同步会主内存中(执行store、write操作) 规则保证。final修饰的字段在构造器中一旦初始化完成，且构造器没将”this“的引用传递出去，其他线程就能看到final字段的值。

​	有序性：Java中，如果在本线程内观察，所有的操作都是有序的(线程内表现为串行的语义)；如果在一个线程内观察另一个线程，所有的操作都是无需的(指令重排序和工作内存和主内存同步延迟)。volatile变量通过内存屏障保证。synchronized由 一个变量在同一时刻只允许一个线程对其进行lock操作 规则保证。

#### 先行发生规则

​	先行发生时Java内存模型中定义的亮相操作之间的偏序关系，比如操作A先行发生于操作B，就是说操作B发生之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。通过先行发生规则，我们可以通过几个简单的规则一揽子解决并发环境下两个操作之间是否可能存在冲突的所有问题。

​	Java内存模型中有一些“天然的”先行发生关系，这些关系无须任何同步器协助便已存在，可以在编码中直接使用。

+ 程序次序规则（Program Order Rule）：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。

+ 管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是“同一个锁”，而“后面”是指时间上的先后。

+ volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量

  的读操作，这里的“后面”同样是指时间上的先后。

+ 线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作。

+ 线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。

+ 线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程

  的代码检测到中断事件的发生，可以通过Thread::interrupted()方法检测到是否有中断发生。

+ 对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的

  finalize()方法的开始。

+ 传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出

  操作A先行发生于操作C的结论。

Java语言无须任何同步手段保障就能成立的先行发生规则有且只有上面这些。

​	时间先后顺序与先行发生(逻辑上的发生)原则之间基本没有因果关系，所以我们衡量并发安全问题的时候不要受时间顺序的干扰，一切必须以先行发生原则为准。如根据程序次序规则，代码是按控制流顺序执行，但是因为即时编译器的重排序，导致代码的顺序改变，但是这并不影响先行发生规则的正确性，因为我们在这条线程之中没有办法感知到这一点。















 
