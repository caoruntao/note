# JAVA

## Java代码如何执行

### 执行方式

高级编程语言执行一般分为 编译 和 翻译两种执行方式。

#### 编译执行

​		将 源代码 转换成 机器语言，通常是 二进制形式(机器码) 并保存下来(复用)，等待执行。目的是生成 可执行的程序。
​		优点:
​			因为提前编译生成 机器码，所以直接执行 编译后的文件即可，因此速度较快。
​		缺点:
​			源代码编译后只能在该类机器上运行，无法跨平台。

#### 解释执行

​		在程序运行时，将源代码转换为 机器语言(机器码)，并立即执行。
​		工作模式:
​			1.分析源代码，并且直接执行。
​			2.把源代码翻译成相对更加高效率的中间码，然后立即执行它。
​			3.执行由解释器内部的编译器预编译后保存的代码。
​		优点:
​			跨平台性，因为无需编译，因此只要解释器支持多平台，就有跨平台性。
​		缺点:
​			运行速度慢，解释器要额外的开销。

### Java执行方式

源代码(.java) - javac -> 字节码(.class) - jvm -> 机器码。先通过javac编译为字节码(Java字节码指令被固定为一个字节)，执行时JVM将字节码解释为机器码(不同平台有对应的JVM，因此可以跨平台)。虚拟机另一个好处是带来一个托管环境(Managed Runtime)，可以帮我们处理一些代码冗余而且容易出错的部分，如内存管理和垃圾回收等。

运行时属于解释执行，为了提高运行效率(程序符合二八原则，20%的代码占用80%的资源)，JVM也提供了编译执行的方式。因此JVM属于混合执行，可通过JVM参数控制。

#### 编译执行机制		

###### JIT(Just In Time)

即时编译。运行时，以方法为单位，将频繁执行的热点代码编译为机器码保存起来(Code Cache，非堆区)，编译完成后(编译时还是以解释的方式执行，编译和解释执行可以并行)，后续调用则直接调用编译完成后的机器码，提高运行效率。

编译器:

​	C1:

​		client模式，将由1500次的收集计算出，启动性能好。

​	C2:

​		server模式，将根据10000次的收集计算出，峰值性能好。

​	Graal:

从Java7开始，HotSpot(JVM)默认采用分层编译的方式:热点方法先被C1编译，然后热点方法中的热点会被进一步被C2编译。为了不干扰应用的正常运行，即时编译是放在额外的编译线程中执行的。HotSpot会根据CPU的数据量设置编译线程的数据，并且按1:2的比例配置C1和C2的编译器。

理论上讲，即时编译后的Java程序的执行效率是可能超过C++的。这是因为和静态编译相比，即时编译拥有程序运行时信息，并且根据这个信息做出优化。

###### AOT(Ahead-of-Time Compilation)

运行之前，将应用中或JDK中的字节码编译成机器码(与即时编译器区别)



## 基本数据类型

Java语言中类型分为两大类，基本数据类型和引用类型。基本数据类型有八个，分别为boolean、byte、char、short、int、long、float、double。引用类型分为四种，分别为类、接口、数组、泛型，因为泛型是通过类型擦除(考虑到向后兼容)实现的，所有可以认为只存在前三种。

Java引入基本数据类型来支持数值计算，因为使用基本数据类型能够提高程序执行效率和减少内存占用。所有的计算操作都会被转换成整数运算。

| 类型    | 值域                 | 默认值   | 虚拟机内部符号 |
| ------- | -------------------- | -------- | -------------- |
| boolean | {false, true}        | false    | Z              |
| byte    | [-128, 128]          | 0        | B              |
| char    | [0, 65535]           | '\u0000' | C              |
| short   | [-32768, 32767]      | 0        | S              |
| int     | [-2^31, 2^31 - 1]    | 0        | I              |
| long    | [-2^63, 2^63 - 1]    | 0L       | J              |
| float   | ~[-3.4E38, 3.4E38]   | +0.0F    | F              |
| double  | ~[-1.8E308, 1.8E308] | +0.0D    | D              |

boolean在Java语言规范中使用true或false来表示，在JVM规范中，boolean会映射为int类型，true映射为1，false映射为0，编码规范约束了Java字节码的具体实现。

if(boolean) 会判断boolean是否为0，0就跳过。if(boolean == true)会判断boolean是否为1，不为1就跳过。



Java虚拟机每调用一个Java方法便会创建一个栈帧。在解释器的解释栈帧中，主要包括两个主要组成部分，分别是局部变量区()和字节码的操作数栈。这里的局部变量是广义的，除了普遍意义下的局部变量之外，它还包含实例方法的“this 指针”以及方法所接收的参数。

在 Java 虚拟机规范中，局部变量区等价于一个数组，并且可以用正整数来索引。除了 long、double 值需要用两个数组单元来存储之外，其他基本类型以及引用类型的值均占用一个数组单元。当然，这种情况仅存在于局部变量，而并不会出现在存储于堆中的字段或者数组元素上。

如将int类型的值存储到boolean类型时，为了保证堆中的 boolean 值是合法的，HotSpot 在存储时显式地进行掩码操作，也就是说，只取最后一位的值存入 boolean 字段或数组中。Java 虚拟机的算数运算几乎全部依赖于操作数栈。也就是说，我们需要将堆中的 boolean、byte、char 以及 short 加载到操作数栈上，而后将栈上的值当成 int 类型来运算。对于无符号类型，加载伴随着零扩展(高位补0)。对于有符号类型，加载伴随着符号扩展(类型值填充低字节，正数最高位补0，负数补1，其余全部补0)。

## Java类如何加载

### 类加载器

JDK8及之前

启动类加载器：加载最为基础、最为重要的类，如存放在JRE的lib目录下的jar包中的类(以及由虚拟机参数-Xbootclasspath指定的类)。由C++编写，在java代码中表现为null。

扩展类加载器：加载相对次要、但又通用的类，比如存放在JRE的lib\ext目录下jar包中的类(以及由系统变量java.ext.dirs指定的类)。

应用类加载器：负责加载应用程序路径下的类(指由虚拟机参数-cp/-classpath、系统环境变量java.class.path指定的路径)。默认情况下，应用程序中包含的类便是由应用类加载器加载的。

JDK9及现在(引入模块化)

启动类加载器：加载少数几个关键模块，如java.base。

平台类加载器：其他模块。

程序类加载器

### 双亲委派机制

每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。

提供了隔离机制，在 Java 虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。提供了安全机制，最核心的类(如String)由启动类加载器加载，不可被相同类名的文件破坏。

### 类加载过程

#### 加载：

​	根据类的全限定名将该类的字节码加载到内存，生成代表该类的Class对象

#### 链接：

​	将创建好的Class对象合并到JVM，使之能够执行的过程。

##### 验证：

​	确保被加载类能够满足 Java 虚拟机的约束条件。

##### 准备：

​	为被加载类的静态字段分配内存，并设置默认值。被final修饰的static字段不会设置，因为在编译时就分配了。

##### 解析：

​	将类成员的符号引用变成直接引用。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。）

#### 初始化：

​	执行类的构造器方法init()的过程。这个方法不需要定义，是javac编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并来的。



类加载时不一定会触发初始化，只用主动使用类时，才会触发，如

1. 当虚拟机启动时，初始化用户指定的主类；
2. 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；
3. 当遇到调用静态方法的指令时，初始化该静态方法所在的类；
4. 当遇到访问静态字段的指令时，初始化该静态字段所在的类；
5. 子类的初始化会触发父类的初始化；
6. 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；
7. 使用反射 API 对某个类进行反射调用时，初始化这个类；
8. 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。

## Java如何执行方法调用

### Java方法调用

#### 重载

在 Java 程序里，如果同一个类中出现多个名字相同，但参数类型不同的方法，我们称之为重载。

重载的方法在编译过程中即可完成识别。具体到每一个方法调用，Java 编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法。选取的过程共分为三个阶段：

1. 在不考虑对基本类型自动装拆箱（auto-boxing，auto-unboxing），以及可变长参数的情况下选取重载方法；
2. 如果在第 1 个阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；
3. 如果在第 2 个阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法。

如果 Java 编译器在同一个阶段中找到了多个适配的方法，那么它会在其中选择一个最为贴切的，而决定贴切程度的一个关键就是形式参数类型的继承关系。

除了同一个类中的方法，重载也可以作用于这个类所继承而来的方法。也就是说，如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型不同，那么在子类中，这两个方法同样构成了重载。

#### 重写

如果子类具有一个和父类非私有方法的方法名，方法参数，方法返回值(可以不一致，但是必须是返回值的子类)一致的方法，如果是非静态的方法可以认为子类重写了父类方法，如果是静态方法，可以认为子类中的方法会隐藏掉父类的方法。

众所周知，Java 是一门面向对象的编程语言，它的一个重要特性便是多态。而方法重写，正是多态最重要的一种体现方式：它允许子类在继承父类部分功能的同时，拥有自己独特的行为。

### JVM方法调用

Java 虚拟机识别方法的关键在于类名、方法名以及方法描述符（method descriptor）。方法描述符是由方法的参数类型以及返回类型所构成。在同一个类中，如果同时出现多个名字相同且描述符也相同的方法，那么 Java 虚拟机会在类的验证阶段报错。

#### JVM 的静态绑定和动态绑定

Java 虚拟机与 Java 语言不同，它并不限制名字与参数类型相同，但返回类型不同的方法出现在同一个类中，对于调用这些方法的字节码来说，由于字节码所附带的方法描述符包含了返回类型，因此 Java 虚拟机能够准确地识别目标方法。

Java 虚拟机中关于方法重写的判定同样基于方法描述符。也就是说，如果子类定义了与父类中非私有、非静态方法同名的方法，那么只有当这两个方法的参数类型以及返回类型一致，Java 虚拟机才会判定为重写。

对于 Java 语言中重写而 Java 虚拟机中非重写的情况，编译器会通过生成桥接方法来实现 Java 中的重写语义。

在某些文章中，重载也被称为静态绑定（static binding），或者编译时多态（compile-time polymorphism）；而重写则被称为动态绑定（dynamic binding）。Java 虚拟机中的静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。

Java 字节码中与调用相关的指令共有五种：

1. invokestatic：用于调用静态方法。
2. invokespecial：用于调用私有实例方法、构造器，以及使用 super 关键字调用父类的实例方法或构造器，和所实现接口的默认方法。
3. invokevirtual：用于调用非私有实例方法。
4. invokeinterface：用于调用接口方法。
5. invokedynamic：用于调用动态方法。

#### 调用指令的符号引用

​	在编译过程中，我们并不知道目标方法的具体内存地址。因此，Java 编译器会暂时用符号引用来表示该目标方法。这一符号引用包括目标方法所在的类或接口的名字，以及目标方法的方法名和方法描述符。

​	符号引用存储在 class 文件的常量池之中。根据目标方法是否为接口方法，这些引用可分为接口符号引用和非接口符号引用。在执行使用了符号引用的字节码前，Java 虚拟机需要解析这些符号引用，并替换为实际引用。

​	对于非接口符号引用，假定该符号引用所指向的类为 C，则 Java 虚拟机会按照如下步骤进行查找。

1. 在 C 中查找符合名字及描述符的方法。
2. 如果没有找到，在 C 的父类中继续搜索，直至 Object 类。
3. 如果没有找到，在 C 所直接实现或间接实现的接口中搜索，这一步搜索得到的目标方法必须是非私有、非静态的。并且，如果目标方法在间接实现的接口中，则需满足 C 与该接口之间没有其他符合条件的目标方法。如果有多个符合条件的目标方法，则任意返回其中一个。

​	从这个解析算法可以看出，静态方法也可以通过子类来调用。此外，子类的静态方法会隐藏（注意与重写区分）父类中的同名、同描述符的静态方法。

​	对于接口符号引用，假定该符号引用所指向的接口为 I，则 Java 虚拟机会按照如下步骤进行查找。

1. 在 I 中查找符合名字及描述符的方法。
2. 如果没有找到，在 Object 类中的公有实例方法中搜索。
3. 如果没有找到，则在 I 的超接口中搜索。这一步的搜索结果的要求与非接口符号引用步骤 3 的要求一致。

​	经过上述的解析步骤之后，符号引用会被解析成实际引用。对于可以静态绑定的方法调用而言，实际引用是一个指向方法的指针。对于需要动态绑定的方法调用而言，实际引用则是一个方法表的索引。


	lambda
	 	peek:
	 		Consumer，无返回值，因此返回的Stream和之前的Stream一样。但是修改Stream中元素对象的属性，对象还是会发生变化的
	 	map:
	 		Function，有返回值，因此返回的Stream就是你的返回值组成的Stream。同时修改Stream中元素对象的属性，对象也会发生变化的。
	 	flatmap:
	 		将元素铺平(如Array)。如果你想将一个String，分割为一个个字符，但是你又不想接收一个Array<String>，那么你可以用flatmap，该方法会将Array的各个元素取出铺平。
	 		List<String> collect = stringList.stream().flatMap(s -> Arrays.stream(s.split(""))).collect(Collectors.toList());
	 		List<String[]> collect1 = stringList.stream().map(s -> s.split("")).collect(Collectors.toList());
	
	获取类的方法：
		Class.forName()
		类名.class
		实例.getClass()
	
	线程池执行流程：
		先看当前线程数是否小于corePoolSize
			如果小于则新建线程执行该任务。
			如果不小于，则看是否可以加入任务队列
				如果可以加入，就加入到任务队列
				如果不可以加入，则看当前线程数是否小于maximumPoolSize：
					如果小于则新建线程执行任务
					如果不小于，则选择拒绝策略

